
	 初心者のためのネットハックソースガイド 
	 (BEGINNER'S GUIDE TO NETHACK SOURCES)
        ---------------------- by German Martin --
                                        german@spain.hp.com

	With additional material by J. Ali Harlow, ali@juiblex.co.uk

	訳 So-Miya (so-miya@users.sourceforge.jp)

				   version 1.1  January '02

目次
--------

   1. この文章について
   2. よし，このゲームを改造したい！
   3. 手始めに
   4. ウィザードモード
   5. 新しい階層を作る
   6. 新しい怪物を作る
   7. 作った怪物を改良する
	   7.0. 'monst'構造体
	   7.1. 新しい攻撃タイプの追加
	   7.2. 新しい怪物の能力の追加
	   7.3. 'mextra'構造体の追加
	   7.4. databaseへの項目追加
   8. 新しいアイテムの追加
	   8.0. 'objects'配列
	   8.1. 道具の追加
	   8.2. 杖の追加
	   8.3. 薬の追加
	   8.4. 防具/武器の追加
	   8.5. 指輪の追加
	   8.6. 魔除けの追加
	   8.7. 魔法書の追加
	   8.8. 食料の追加
   9. 新しい種類の部屋の作成
  10. 新しい種類の店の作成
  11. 最後に
  付録A. リファレンス関数一覧


1. この文章について
----------------------

  　NetHackを何[ヶ月|年]も遊んで，かつ楽しんでいる？
  誰も聞いてくれないようなこのゲームに対するクールで新しいアイデアを持って
  いる？ Cコンパイラが入っているマシンにアクセスできる？ プログラムをした
  ことはある？

  　もしこれらの質問にYesと答えるならば，この文書は君の役に立つかもしれな
  い．

  　僕は'94ぐらいからNetHackのソースを覗き始めたんだ．このゲームが好きだか
  らいくつかの新しい怪物や機能を追加したくなったんだけど，相当に難しい仕事
  だった． 僕はCの初心者じゃないんだけど，100 (あるいはそれ以上)もあるソー
  スファイルは僕の手に負える量じゃなかった． コードの開始地点であるmain()
  を探すことすら難しかったんだ． インラインコメントによって与えられるヘル
  プは新参者には役に立たないものだったしね． 今，9ヶ月かかって，このコード
  の主構造はおおまかに覚えることができた． 新しい怪物，アイテム，部屋，階
  層そしてふるまいを追加できるようになった． 僕（念のため，開発チームでは
  ないよ）はこの巨大な怪物の全てを理解しているわけではないので，この文書は
  コードの完璧なガイドではなく，新しいアイデアをこのゲームに追加するために
  役に立つことを目的にしている．

  　したがって，これが正確でないことが発見されるのは全くありえることで…
  君は予想以上に―それは確実に―不完全なものを発見するだろう．
  OK，バグ/コメント/追記を僕に送ってくれれば，僕が修正/追記をしよう．

  　お願い．これは自己責任で使ってほしい． 要求不満しか得られなくても
  僕を非難しないでほしい． 僕は役に立ちたかっただけなんだ．

  　この文書の全ての内容はNethack 3.1.3(この文書を書いてる時点での公式最新版)
  を基にしている．


2. よし，このゲームを改造したい！
----------------------------------

  　OK． 君は先週からnethackを遊び始めて，Unixマシンのアカウントを手に入れて，
  こう考えた．「よし，すごくいい考えが浮かんだぞ！ このゲームを改造しながら
  C言語の勉強だ！ このレシピがあるから全てうまくいくさ！」 それは無理だ．
  君がレオナルド・ダ・ビンチの生まれ変わりでもない限り，頭痛に悩まされるだけだ．

  　言い換えれば，これを活用するには少なくとも次のものが必要だ．

     - 君が今使っているOSに関する少々の知識． すなわち，ファイルを編集したり，
     　移動させたり，作ったり，削除したりする基本的なやり方．

     - C言語に関するある程度の知識． すなわち，printf("Hello world\n") 
     　プログラム以上のもの． Cプリプロセッサも含む．

     - Cコンパイラとそれを安心して使えること．

     - 祝福された能力獲得の薬．


3. 手始めに
-----------------

   最初に必要なのは，ソースを君自身でコンパイルできることだ． 全プロセスを
   理解しなくてもいいけれど，ゲームになにがしか追加する前に公式コードがコ
   ンパイルできて，それが動かせること必要だ． 一番上のディレクトリのREADME
   ファイルと，/sys/XXXディレクトリのInstall.XXX (XXXは君のOSごとに異なる)
   を参照すること．

   いったんソースのコンパイルが成功すれば，今度は何をすべきか気づくはずだ．


4. ウィザードモード
------------------
   君はおそらく知っているだろうが，ウィザードモードは次のような少々の特殊
   なコマンド付きでnethackを実行する方法だ．

		^E  ==  扉と罠の表示．
		^F  ==  魔法の地図の実行．
		^G  ==  怪物生成．
		^I  ==  所持品の鑑定．
		^O  ==  特殊レベルの一覧．
		^T  ==  同じ階での瞬間移動．
		^V  ==  別の階へ瞬間移動．
		^W  ==  願いを叶える．
		^X  ==  属性を見る．

   　その他いくつかの挙動が変更されるんだ． 例えば，怪物を作る巻物を読むと
   モンスターの種類を指定できるとかね．

   これらがあれば君が追加した新しい機能や変更点の確認がすぐにできる．
   開始するには次のようにタイプするだけでいい．

                nethack -u wizard -D

   これで一応動くけど，次の点に注意：

   - unixマシンの場合，正しいuser-idでなくちゃならない．
   - include/config.hを見て，#define WIZARDの行を検索してくれ．
   　-uの後ろに入力する名前はここのものと同じにする必要がある．

   君はnethackの修正とその修正内容の確認を通して，この拡張モードの使用方法
   を覚えていくべきだ．(精霊界における君の新しい怪物を試すためにゲームを
   完全にプレイするのに代わる手段としてね :-) ）


5. 新しい階層を作る
-----------------------

   新しい階層を作るのは簡単だ． 実を言うと，Cについて何も知らなくていい．
   開発チームが僕達のためにそれを用意してくれている．

   nethackの実行環境を構築するときに'util'ディレクトリ下にある'lev_comp'と
   いうプログラム(MS-DOSならばlev_comp.exe)を残しているはずだ．
   そのバイナリはnethack用の新しい特殊階層を作る機能を持つ．
   それにデスクリプションファイル(ファイル名は<XXX>.des)を指定すれば，
   nethack用の階層ファイル(ファイル名は<XXX>.lev)を生成してくれる．


            mylevel.des -----------
                                   |
                                __ | __
                                \  V  /
                              ___\___/___
                              |         | _
                              |lev_comp |/
                              |         |  -----> mylevel.lev
                              -------------

   lev_compコンパイラには'lev_comp.6'と呼ばれるマニュアルがついている
   ("doc"ディレクトリ参照)． もし君がunixマシンを使っているなら次のコマン
   ドで標準的な書式のマニュアルを参照できる．
                          nroff -man lev_comp.6 | more
   もしそうでないなら…うーむ，そのファイルの.SHや.PPなどのゴミに慣れても
   らうしかないかな．(訳注：3.2以降では整形済みのlev_comp.txtが同梱されて
   いるのでそちらを利用しよう．英語だけど．) このマニュアルには(結構わかり
   づらいけど).desファイルの作りかたが載っている．
   例として，"dat/castle.des"ファイルの始めの部分を見てみよう．

	MAZE:"castle",random
	FLAGS: noteleport
	GEOMETRY:center,center
	MAP
	}}}}}}}}}.............................................}}}}}}}}}
	}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}
	}|.....|-----------------------------------------------|.....|}
	}|.....+...............................................+.....|}
	}-------------------------------+-----------------------------}
	}}}}}}|........|..........+...........|.......S.S.......|}}}}}}
	.....}|........|..........|...........|.......|.|.......|}.....
	.....}|........------------...........---------S---------}.....
	.....}|...{....+..........+.........\.S.................+......
	.....}|........------------...........---------S---------}.....
	.....}|........|..........|...........|.......|.|.......|}.....
	}}}}}}|........|..........+...........|.......S.S.......|}}}}}}
	}-------------------------------+-----------------------------}
	}|.....+...............................................+.....|}
	}|.....|-----------------------------------------------|.....|}
	}-------}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}-------}
	}}}}}}}}}.............................................}}}}}}}}}
	ENDMAP

   わかりやすいだろ？ このファイルの内容から城レベルが作られるんだ． ここ
   の部分は階層の外見部分を定義している． 城を中央にして両脇に迷路が描かれ
   る（MAZEの行を注目）．

   このファイルの残りの部分がドア，罠，アイテムおよび怪物をランダムに，あ
   るいは位置を指定する部分になる． (上記の地図の相対的な位置で)

   マニュアルで文法が説明されているから，もし君がその気ならば，ファイル全
   体を今から修正し始めることもできる． だけど，とても簡単な変更からそれが
   どう動くのか見ていこう． 君は城に駐在している兵士は弱いと思い，もっと骨
   のある怪物，例えばミノタウロスとかに変えたいと考えたとしよう．
   次の行を

   MONSTER:'@',"soldier",(08,06)

   次のように変更すればよい．

   MONSTER:'H',"minotaur",(08,06)

   (ここでは怪物を指定することを選択している．僕達は生成される怪物が
    種類別に怪物を生成することを選択することもできる． 次のように

    MONSTER:'D',RANDOM,(08,06)

    ドラゴンをランダムに生成することもできる．)

   新しいcastle.desファイルを保存してdatディレクトリで次を実行しよう．

      ../util/lev_comp castle.des     (MS-DOSでは'/'を'\'に変更する必要がある)

   新しい'castle.lev'ファイルが'dat'ディレクトリに作られる． これを試して
   みるには，出来上がった'castle.lev'を実行ディレクトリ(games/nethackのよ
   うな) にコピーして，ウィザードモードでゲームを起動しよう．城へ瞬間移動
   して，さまよう目の死体と目隠しを願って見てみよう． たくさんの茶色の H
   が見えるはずだ！

   さて，オリジナルを作るのにふさわしい時は来た． 僕達は新しい階層を
   作りたかったのであって，既にあるものを修正することではないからね．
   castle.desからは離れてnewlevel.desを作ってみよう！

   そのために，僕達は新しいコンパイラに慣れる必要がある．
   ダンジョンコンパイラ dgn_comp だ． lev_comp のようにこれにも dgn_comp.6
   というマニュアルがついている． これの目的は，迷宮全体（階層の集合体）
   の設計ファイルからNetHackバイナリ用の"dungeon"ファイルを生成することだ．

   迷宮全体の設計ファイルは"dungeon.def"という：

	DUNGEON:        "The Dungeons of Doom" "D" (25, 5)
	ALIGNMENT:      unaligned
	%MULDGN BRANCH: "The Gnomish Mines" @ (2, 3)
	%REINCARNATION LEVEL:           "rogue" "R" @ (15, 4)
	LEVEL:          "oracle" "O" @ (5, 5)
	LEVALIGN:       neutral
	LEVEL:          "bigroom" "B" @ (10, 3) 15
	%MULDGN CHAINBRANCH:    "The Quest" "oracle" + (6, 2) portal
	%MULDGN BRANCH:         "Fort Ludios" @ (18, 4) portal
	RNDLEVEL:       "medusa" "none" @ (-5, 4) 2
	LEVALIGN:       chaotic
	LEVEL:          "castle" "none" @ (-1, 0)
	CHAINBRANCH:    "Gehennom" "castle" + (0, 0) no_down
	BRANCH:         "The Elemental Planes" @ (1, 0) no_down up

   ご存知のとおり，階層からなる主迷宮は「階層」と分岐である． 一番簡単なの
   は主迷宮にただ階層をひとつ追加するものだ．

   仮に，階層'mylevel'の定義として新しいmylevel.desファイルを生成したとし
   よう．

   MAZE:"mylevel",' '

   (重要： 通常ファイル名はcastle.desのようにMAZEの定義と同じにすること．
    ただし.levファイルの名前はMAZE行での指定から取られることに注意！！)

   主迷宮にこれを追加するには僕達は次の行をビッグルームの後ろに追加すれば
   いい：

   LEVEL:	"mylevel" "none" @ (15,2)

   これは，'mylevel'階層を深さ15±2階の範囲にランダムに生成する． また，こ
   の階層では骨ファイルを生成しない．('none'の部分によって)

   それから"../util/dgn_comp dungeon.def"を実行して'dungeon'ファイルをゲッ
   トしよう． それをゲームディレクトリにコピーして試してみよう．（ウィザー
   ドモードのコマンドCtrl-Oがここでは便利だろう．）

   新しい階層の読み込みの時に何かエラーが発生したら，NetHackは代わりにラン
   ダムな普通の階層をつくる．

   最後に，新しい分岐を迷宮に作りたい場合は，次のように指定する．

   %MULDGN BRANCH: "newbranch" @ (18, 1)

   その後に続けて，新しい分岐内の階層を定義する行を指定していく．

   DUNGEON:        "newbranch" "S" (4,0)
   DESCRIPTION:    mazelike
   LEVEL:          "mylevel1" "none" @ (1, 0)
   LEVEL:          "mylevel2" "none" @ (2, 0)
   LEVEL:          "mylevel3" "none" @ (3, 0)
   LEVEL:          "mylevel4" "none" @ (4, 0)


   さっそくその.desファイルをしばらくいじってその文法に慣れよう． 新しい階
   層や迷宮を作るのはそんなに難しくないだろう？

   ひょっとしたらこの章で君が必要としていたことは全てカバーしたかもしれな
   い． だけど，新たな面白い体験がしたいなら，続けて読んでね．


6. 新しい怪物を作る
-------------------------

      "気をつけろ，多分戻れないぞ！それでも読む？(y/n)"

   モルドールの暗闇の中へようこそ… つらいかもしれないが見返りは大きい．
   修正が開発チームの祝福を受けられれば，君は永遠の生へと到達するだろう！
   どっちにしろ，nethackを修正するとプレイするよりも面白い時を過ごすことが
   できるよ．

   さて，やりますか：

   まず手始めに，君は2つの巨大な配列の存在を知る必要がある． ひとつはありっ
   たけの怪物を定義し，他方はありったけのアイテムを定義している．最初の方
   は'mons'と呼ばれている． これは'permonst'構造体の配列で，中身はsrcディ
   レクトリー配下のmonst.cで定義されている． (ところで，これ以降では僕はファ
   イルがどこにあるかを言及しないよ． そろそろディレクトリ構造に慣れておく
   べきだしね．) 'permonst'構造体はpermonst.hファイルで定義されていて，そ
   れを見ればこの構造体の各要素が何を意味しているかわかるだろう． けど，君
   に便利だろうからここでmons配列に追加する新しい項目を説明しよう．


        {"myself", S_HUMAN, 1, 10, 10, 0, 0, G_GENO | G_NOGEN,
        { { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,
          NO_ATTK, NO_ATTK, NO_ATTK },
        WT_HUMAN, 400, PL_NSIZ, MS_HUMANOID, MZ_HUMAN, 0, 0,
        M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE,
        M2_HUMAN | M2_STRONG | M2_COLLECT, 0, C(HI_DOMESTIC)}

   (訳注：3.2以降ではプリプロセッサを用いて以下のように装飾される．
        MON("myself", S_HUMAN,
           LVL(1, 10, 10, 0, 0), (G_GENO | G_NOGEN),
           A(ATTK(AT_WEAP, AD_PHYS, 1, 6),
             NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK, NO_ATTK),
           SIZ(WT_HUMAN, 400, 0, MS_HUMANOID, MZ_HUMAN), 0, 0,
           M1_NEEDPICK|M1_HUMANOID|M1_OMNIVORE,
           M2_HUMAN|M2_STRONG|M2_COLLECT,
           0, HI_DOMESTIC)
   )

   -name: ("myself") は怪物の名前

   -symbol: (S_HUMAN) は使われる文字． 完全なリストはmonsym.hファイルで
        定義されている．

   -level: (1). この怪物が初めて生成されるレベル．
        (訳注：階とプレイヤーレベルの平均と比較される．)

   -move rate: (10). 0(全く動かない)から30(マジで素早い)まで．

   -AC: (10). しっかりしろよ！君が今五体満足でいるのはこれがあるからだぜ．

   -magic resistance: (0). 魔法抵抗． 0(なし)から127(完全防御)まで．

   -alignment: (0). 属性．負の値で混沌を意味し，正の値で秩序を表す．

   -creation/geno flags: (G_GENO | G_NOGEN)  生成/虐殺フラグ
	このフラグまたは数値の意味は次のとおり：

        G_UNIQ          /* 一度しか生成されない */
        G_NOHELL        /* 地獄(hell)では生成されない */
        G_HELL          /* 地獄(hell)でのみ生成される */
        G_NOGEN         /* 特殊な場合でのみ生成される */
        G_NOCORPSE      /* 絶対死体を残さない */
        G_SGROUP        /* 通常小集団で現れる */
        G_LGROUP        /* 通常大集団で現れる */
        G_GENO          /* 虐殺可能 */
         (訳注：定義においては，0〜7が出現頻度として扱われる．)
         (訳注：以降は数値的には0〜7であり，ゲーム内でのみ使用される．)
        G_KNOWN         /* 遭遇済み */
        G_GONE          /* 虐殺済みもしくは絶滅済み */
        G_GENOD         /* 虐殺済み */
        G_EXTINCT       /* 人口抑制のため絶滅済み */
        G_FREQ          /* 生成関連フラグのマスク */

                 (monsym.hより)
                 (訳注：3.2以降ではmonflag.h)

   -attack: ({ { AT_WEAP, AD_PHYS, 1, 6 }, NO_ATTK, NO_ATTK,
           NO_ATTK, NO_ATTK, NO_ATTK },)
      これは怪物の攻撃方法を定義する． 6つの'attack'構造体を要素として含む．
      要素内が何を意味するかは次のとおり．

	  ( 攻撃タイプ, ダメージタイプ, ダイス数, ダイス面数 )

      攻撃タイプは次のどれか一つになる：

        AT_NONE         /* 受身の怪物 (例：酸のブロッブ) */
        AT_CLAW         /* 爪で引っかく (殴る，叩く，等) */
        AT_BITE         /* 噛み付く */
        AT_KICK         /* 蹴る */
        AT_BUTT         /* 頭突き (例：ユニコーン) */
        AT_TUCH         /* 触れる */
        AT_STNG         /* 刺す */
        AT_HUGS         /* 破壊目的の抱きつき */
        AT_SPIT         /* 物質を吐く − 遠距離攻撃 */
        AT_ENGL         /* 飲み込み (生物や渦巻きに) */
        AT_BREA         /* ブレスを吐く − 遠距離攻撃 */
        AT_EXPL         /* 爆発 − 近接攻撃 */
        AT_GAZE         /* 睨む − 遠距離攻撃 */
        AT_TENT         /* 触手で絡みつく */
        AT_WEAP         /* 武器を用いる */
        AT_MAGC         /* 魔法の呪文(複数有)を用いる */
        (訳注：以下はNetHack3.3.0以降で追加されたもの)
        AT_BOOM         /* 死亡時に爆発 */
        (訳注：以下はSLASH'EMで追加されたもの)
        AT_MULTIPLY     /* 分裂（実は攻撃）*/

      ダメージタイプは次のどれか一つになる：

        AD_PHYS         /* 通常の物理ダメージ */
        AD_MAGM         /* 魔法のミサイル */
        AD_FIRE         /* 火のダメージ */
        AD_COLD         /* 寒さのダメージ */
        AD_SLEE         /* 睡眠光線 */
        AD_DISN         /* 分解（死の光線） */
        AD_ELEC         /* 電撃のダメージ */
        AD_DRST         /* 強さの吸収（毒） */
        AD_ACID         /* 酸のダメージ */
        AD_SPC1         /* buzz()関数用の拡張 */
        AD_SPC2         /* buzz()関数用の拡張 */
        AD_BLND         /* 盲目ダメージ (発光する目)
         (訳注：glowing eyeは3.1のモンスター．今は黄色い光)*/
        AD_STUN         /* 眩暈 */
        AD_SLOW         /* 減速 */
        AD_PLYS         /* 麻痺 */
        AD_DRLI         /* 生命力吸収（吸血鬼） */
        AD_DREN         /* 魔力吸収 */
        AD_LEGS         /* 足を傷つける（ザン） */
        AD_STON         /* 石化（メデューサ，コカトリス） */
        AD_STCK         /* 捕まえる（ミミック） */
        AD_SGLD         /* 金貨を盗む（レプラコーン） */
        AD_SITM         /* アイテムを盗む（ニンフ） */
        AD_SEDU         /* 魅了してアイテムを複数盗む */
        AD_TLPT         /* 瞬間移動させる（両氏物理学者） */
        AD_RUST         /* 防具を錆びさせる（錆の怪物）*/
        AD_CONF         /* 混乱させる（アンバーハルク） */
        AD_DGST         /* 相手を消化する（トラッパー等） */
        AD_HEAL         /* 相手の傷を癒す（看護婦） */
        AD_WRAP         /* ウナギ用「巻きつき」 */
        AD_WERE         /* 獣化病に罹患させる */
        AD_DRDX         /* 器用さ吸収（クアシト）*/
        AD_DRCO         /* 耐久力吸収 */
        AD_DRIN         /* 知力吸収（マインドフレア）*/
        AD_DISE         /* 病気に罹患させる */
        AD_DCAY         /* 有機物を腐らせる（茶色プリン） */
        AD_SSEX         /* サキュバスの誘惑（拡張） */
        AD_DETH         /* デス専用 */
        AD_PEST         /* ペスティレンス専用 */
        AD_FAMN         /* フェミン専用 */
        AD_CLRC         /* ランダムな僧侶呪文 */
        AD_SPEL         /* ランダムな魔法呪文 */
        AD_RBRE         /* ランダムなブレス */
        AD_SAMU         /* 攻撃して魔よけを盗む（かの魔法使い） */
        AD_CURS         /* ランダムに（訳注：能力を）呪う（例：グレムリン）*/
        (訳注：以下はNetHack3.2以降で追加されたもの)
        AD_HALU         /* 幻覚を引き起こす */
        (訳注：以下はNetHack3.3.0以降で追加されたもの)
        AD_SLIM         /* グリーンスライムと化す */
        AD_ENCH         /* 強化魔法を消去する（吸魔の怪物） */
        (訳注：以下はNetHack3.3.1以降で追加されたもの)
        AD_CORR         /* 防具を腐食させる（黒プリン）*/
        (訳注：以下はSLASH'EMで追加されたもの)
        AD_CALM         /* 敵意を鎮める（コアラ）*/
        AD_POLY         /* 変化させる（遺伝子工学研究者）*/
        AD_TCKL         /* くすぐる（夜のゴーント）*/

      ダイス数, ダイス面数はダメージ幅を定義する：
        例： 1,6 ならばダメージは1から6の間を意味する．
             3,7 ならばダメージは3から27の間を意味する．
        (訳注： それぞれ，6面ダイスを1個振る，7面ダイスを3個振るということ)

      そして，怪物は1ターンあたり最大で6回攻撃できる． それより少ない攻撃回数
      の場合は'NO_ATTACK'を使う．

   -weight: (WT_HUMAN). 重さ．WT_DRAGON，WT_HUMAN，WT_ELFといった定数でも
      いいけど，直接数値を指定することもできる．

   -nutritional value: (400). 栄養価．

   -extension length: (PL_NSIZ). これが難しい…これは通常のpermonstを
     拡張した情報をもつモンスターにおいてその拡張に必要なサイズである． 例
     えば，店番は店に関するコードを管理する特殊な構造体を持つし，犬ならば
     飼いならし度を管理する拡張，などなど… とりあえずこの部分は忘れよう．
     (訳注：PL_NSIZという定数は3.2以降でなくなり，0が指定されるようになっ
      た．店番ならsizeof(struct eshk)と記述される．また，犬以外のあらゆる
      モンスターがペットになりうるのでペットに関する拡張は動的に行われる．)

   -sounds made: (MS_HUMAN). 音声． 以下のいずれか一つ：（monflag.hより）

        MS_SILENT       /* 音を立てない */
        MS_BARK         /* 満月時に吠える */
        MS_MEW          /* ニャーまたはシャーッ */
        MS_ROAR         /* 吠える */
        MS_GROWL        /* 激しく吠える */
        MS_SQEEK        /* ねずみのようにキーキー鳴く */
        MS_SQAWK        /* 鳥のようにガァガァ鳴く */
        MS_HISS         /* シーッと鳴く */
        MS_BUZZ         /* 羽音をたてる (殺人蜂) */
        MS_GRUNT        /* うなり声をあげる (あるいは独自の言語でしゃべる) */
        MS_NEIGH        /* ウマのようにいななく */
        MS_WAIL         /* 苦しむ魂のように悲しげに鳴く */
        MS_GURGLE       /* 液体やよだれのようにごぼごぼ鳴る */
        MS_BURBLE       /* ぶーぶく (ジャバウォック) */
        MS_ANIMAL       /* 上記までを動物の鳴き声と定義する
                           (訳注：怪物の定義には使用しない) */
        MS_SHRIEK       /* 他の怪物を起こす */
        MS_BONES        /* 骨を鳴らす（骸骨）*/
        MS_LAUGH        /* にやり，にっこり，くすくす，ゲラゲラ */
        MS_MUMBLE       /* 何かをつぶやく */
        MS_IMITATE      /* 他の物まね（レオクロッタ）*/
        MS_ORC          /* 知性ある獣（訳注：MS_GRUNTと同値） */
        MS_HUMANOID     /* 一般的な同業者 */
        MS_ARREST       /* 「法の名のもと直ちに中止せよ！」（警備員） */
        MS_SOLDIER      /* 軍や見張りの言い回し */
        MS_GUARD        /* 「金を置いてついてきてください．」 */
        MS_DJINNI       /* 「私を助けてくれたことに感謝する！」 */
        MS_NURSE        /* 「シャツを脱いでください．」 */
        MS_SEDUCE       /* 「こんにちは．あらいい男ね．」（ニンフ）*/
        MS_VAMPIRE      /* 吸血鬼の誘惑，ヴラドの叫び */
        MS_BRIBE        /* 通行料を要求するか，怒鳴りつける */
        MS_CUSS         /* 怒鳴りつける（悪魔）が，脅す（かの魔法使い） */
        MS_RIDER        /* 精霊界の特殊な怪物 */
        MS_LEADER       /* クエストリーダー */
        MS_NEMESIS      /* クエストネメシス */
        MS_GUARDIAN     /* クエストガーディアン */
        MS_SELL         /* 支払いを求め，万引きの不満を漏らす */
        MS_ORACLE       /* 神託を告げる */
        MS_PRIEST       /* 寄付を募り，浄化する */
        (訳注：以下はNetHack3.2以降で追加されたもの)
        MS_SPELL        /* 上記に合致しない呪文を唱える者 */
        MS_WERE         /* 人間形態の獣人 */
        MS_BOAST        /* 巨人 */
        (訳注：以下はSLASH'EMで追加されたもの)
        MS_GYPSY        /* ジプシー */
        MS_SHEEP        /* 羊 */
        MS_CHICKEN      /* ニワトリ */
        MS_COW          /* 雄牛と牝牛 */
        MS_PARROT       /* 鳩 */


   -physical size: (MZ_HUMAN). 物理的な大きさ．次のうちの一つ：

        MZ_TINY         0               /* < 2フィート(〜0.6m) */
        MZ_SMALL        1               /* 2-4フィート(0.6〜1.2m) */
        MZ_MEDIUM       2               /* 4-7フィート(1.2〜2.1m) */
        MZ_HUMAN        MZ_MEDIUM       /* 人のサイズ */
        MZ_LARGE        3               /* 7-12フィート(2.1〜3.7m) */
        MZ_HUGE         4               /* 12-25フィート(3.7〜7.6m) */
        MZ_GIGANTIC     7               /* 計測不能 */

   -resistance conferred (randomly) 食べた時得られる耐性: (0)

        MR_FIRE         /* 火への耐性 */
        MR_COLD         /* 寒さへの耐性 */
        MR_SLEEP        /* 眠りへの耐性 */
        MR_DISINT       /* 粉砕への耐性 */
        MR_ELEC         /* 電撃への耐性 */
        MR_POISON       /* 毒への耐性 */
        MR_ACID         /* 酸への耐性 */
        MR_STONE        /* 石化への耐性 */
        (訳注：他の食べて得られない耐性として魔法や病気に対するものがある．)
        (訳注：他の死体を食べた時得られる特性として瞬間移動，瞬間移動制御，
               テレパシーがある．)

   -First group of flags: (怪物のふるまいのフラグ１)
          (M1_NEEDPICK | M1_HUMANOID | M1_OMNIVORE)

        M1_FLY          /* 飛べる，浮ける */
        M1_SWIM         /* 水上を泳げる */
        M1_AMORPHOUS    /* 扉の下から滲み出せる */
        M1_WALLWALK     /* 岩盤を透過できる */
        M1_CLING        /* 天井に張りつける */
        M1_TUNNEL       /* 岩盤を掘り進める */
        M1_NEEDPICK     /* 掘り進むのにつるはしが必要 */
        M1_CONCEAL      /* アイテムの下に隠れられる */
        M1_HIDE         /* 偽装したり，天井に一体化できる */
        M1_AMPHIBIOUS   /* 水中で生きられる */
        M1_BREATHLESS   /* 呼吸を必要としない */
        M1_NOEYES       /* 睨むべき目がないか，盲目 */
        M1_NOHANDS      /* 物をつかむ手を持たない */
        M1_NOLIMBS      /* 蹴ったり装備したりする手足がない */
        M1_NOHEAD       /* 打ち首にする頭がない */
        M1_MINDLESS     /* 精神がない−ゴーレム，ゾンビ，モールド */
        M1_HUMANOID     /* 人型の頭，腕，胴を持つ */
        M1_ANIMAL       /* 動物の身体を持つ */
        M1_SLITHY       /* ヘビの身体を持つ */
        M1_UNSOLID      /* 実体を持たない，または液状の身体を持つ */
        M1_THICK_HIDE   /* 厚い皮や鱗を持つ */
        M1_OVIPAROUS    /* 卵を産める */
        M1_REGEN        /* 体力回復能力 */
        M1_SEE_INVIS    /* 透明な生物を見ることができる */
        M1_TPORT        /* 瞬間移動できる */
        M1_TPORT_CNTRL  /* 瞬間移動位置を制御できる */
        M1_ACID         /* 食べると酸性 */
        M1_POIS         /* 食べると毒 */
        M1_CARNIVORE    /* 死体を食べる */
        M1_HERBIVORE    /* フルーツを食べる */
        M1_OMNIVORE     /* 両方食べる */
        M1_METALLIVORE  /* 金属を食べる */


   -Second group of flags: (怪物のふるまいのフラグ２)
        (M2_HUMAN | M2_STRONG | M2_COLLECT)

        M2_NOPOLY       /* プレイヤーはこれに変化できる */
        M2_UNDEAD       /* 生ける死者である */
        M2_WERE         /* 獣人である */
        M2_ELF          /* エルフである */
        M2_DWARF        /* ドワーフである */
        M2_GIANT        /* 巨人である */
        M2_ORC          /* オークである */
        M2_HUMAN        /* 人間である */
        M2_DEMON        /* 悪魔である */
        M2_MERC         /* 番兵か軍人である */
        M2_LORD         /* その種の貴族である */
        M2_PRINCE       /* その種の支配階層である */
        M2_MINION       /* 神の使いである */
        M2_MALE         /* 雄のみで構成される */
        M2_FEMALE       /* 雌のみで構成される */
        M2_NEUTER       /* 男女の区別を持たない */
        M2_PNAME        /* モンスター名は固有名である */
        M2_HOSTILE      /* 常に敵対的に生成される */
        M2_PEACEFUL     /* 常に友好的に生成される */
        M2_DOMESTIC     /* 餌付けして手懐けられる */
        M2_WANDER       /* ふらふらさまよう */
        M2_STALK        /* 別の階層に追いかける */
        M2_NASTY        /* 特別に厄介な怪物である（経験値増）*/
        M2_STRONG       /* 強い(または大きい) 怪物 */
        M2_ROCKTHROW    /* 岩を投げる */
        M2_GREEDY       /* 金が好き */
        M2_JEWELS       /* 宝石が好き */
        M2_COLLECT      /* 武器と食料を拾う */
        M2_MAGIC        /* 魔法のアイテムを拾う */

   -Third group of flags: (0) (怪物のふるまいのフラグ３)

        M3_WANTSAMUL    /* かの魔よけを欲する */
        M3_WANTSBELL    /* かのベルを欲する */
        M3_WANTSBOOK    /* かの書を欲する */
        M3_WANTSCAND    /* かの燭台を欲する */
        M3_WANTSARTI    /* クエストアーティファクトを欲する */
        M3_WANTSALL     /* 上記のアーティファクトを全て欲する */
        M3_WAITFORU     /* 君と相対するか攻撃されるまで待つ */
        M3_CLOSE        /* 攻撃されるまでは親しい */
        M3_COVETOUS     /* 何もかも欲する */
        M3_WAITMASK     /* 待つ…（訳注：内部用） */
        （訳注：以下はNetHack 3.3以降から追加されたもの）
        M3_INFRAVISION  /* 赤外線による視界を持つ */
        M3_INFRAVISIBLE /* 赤外線で見える */
        （訳注：以下はレーテパッチ経由でSLASH'EMに追加されたもの）
        M3_TRAITOR      /* 裏切ることができる */
        M3_NOTAME       /* 手懐けられない */

   -symbol color: (C(HI_DOMESTIC)) シンボルの色

        C(RED), C(BROWN), C(HI_DOMESTIC), 等々

            (HI_DOMESTIC は友好的な怪物の色である)

   君は輝ける開発チームの定める次のルールを守るべきだ：

  
        ルール #1:      同じクラスの怪物はmons[]配列内で連続するべし．
  
        ルール #2:      同じクラスの怪物は強さの昇順で並べるべし．
  
        ルール #3:      怪物生成頻度は生成/虐殺フラグに含めるべし．
                        これは0〜7の範囲で，0は自然生成されない．
  
        ルール #4:      同じサブクラスの怪物 (例：巨人)はルール #2に反しな
                        い限りまとめるべし．NOGENの怪物はルール #2に反しな
                        い．


   これで全部だね． 通常は，既にある怪物をコピーして始めるのが簡単だよ．
   例えば，もっと強いケンタウロスを作成したいならば，草原のケンタウロスを
   コピーしてきて，ACと攻撃部分を変えればいい．

   さて，君は全コードの再コンパイルをする必要がある． そう，読んだとおり
   *コード全体*だ． どうしてかと言うと，mons配列は全ての怪物に固有番号を
   割り振っていて，後で参照時に使用しているんだ． コンパイルのときに
   'makedefs'コマンドを見たことあるかい？ あれが重要な部分で，モンスターと
   アイテム全ての#defineを生成しているんだ． ほら，pm.hを見てみると，

	/* This source file is generated by 'makedefs'.  Do not edit. */
	#ifndef PM_H
	#define PM_H

	#define PM_GIANT_ANT    0
	#define PM_KILLER_BEE   1
	#define PM_SOLDIER_ANT  2
	#define PM_FIRE_ANT     3

   もうさっきのコマンドが何をしていたか理解できただろう． ソースでは
   それがどこにあるかを知らずにPM_SOMETHING定義を使用して「something」
   モンスターのpermonst構造体にアクセスすることができる．

   もしmakeやndmakeを正しく設定していれば，makeがコードの再コンパイルの手順
   の面倒を引き受けてくれる． *.desファイルも再コンパイルされることに注意
   すること．

   さて，新しい怪物を試すためにnethackをウィザードモードで起動して，
   怪物を造る巻物を願おう． それを読んで，君の怪物の名を入力しよう． 
   やったね！ 君独自の怪物ができた．

   重要事項：
      適切な#ifdefおよび#ifndef命令で君の独自コードを分離しておくことが
      とても重要だ． そしてinclude/config.hファイルの最後に必要な
      #define SOMETHING行を追加しておこう．


7. 作った怪物を改良する
-------------------------

   7.0. 'monst' 構造体

   5章（訳注：6章？）によって，君独自の怪物が迷宮をさまようようになった．
   だけどもっとやりたいことはあるだろう．彼用の具体的なアイテム，武器や防具，
   独自の会話文等々… どうすればできるようになるかな？  読み進めよう．

   今こそ，'monst'構造体について説明しよう． この構造体は「具体的な」怪物
   を定義するものだ． 体力値，懐き具合，等々…  全モンスターの種類の能力を
   定義している 'permonst'構造体とはまるで違う． 'monst'構造体の各要素は
   monst.hで次のように定義されている：

   -nmon: 現階層中にいる全モンスターは連結リストでまとめられている．
   最初の怪物へのディスクリプタ('fmon')から始めて，次の怪物へのポインタを
   たどることで全部の怪物を参照することができる．

                    --------    --------   --------   --------
            fmon -> | nmon ---> | nmon --->| nmon --->| nmon ---> NULL
                    |      |    |      |   |      |   |      |
                    | MONST|    | MONST|   | MONST|   | MONST|
                    |  #1  |    |  #2  |   |  #3  |   |  #4  |
                    --------    --------   --------   --------

   -data: この怪物を定義するpermonst構造体へのポインタ． 例えば，イモリの
   体重なんかの変化しない値をそれぞれの具体的なイモリに持たせるのは
   意味がないよね．

   -m_id: 具体的な怪物ごとの固有番号．生成時に付けられる．

   -mnum: 怪物固定インデックス番号(Permanent monster index number)．
    makedefsによって付けられる．pm.hにてPM_怪物名で#defineされているやつ．
    怪物の種類ごとに固有だ．

   -m_lev: 変動後の怪物の倒しにくさレベル． つまり，怪物のレベルは
    初期値のそれから変化しうる．(経験とか，薬などで…)

   -malign: プレイヤーからみた相対的なこの怪物の属性． 正の数値ならば
    殺しちゃっていいことを意味する．

   -mx, my: この階層の地図におけるこの怪物の位置．(x, y 座標)

   -mux,muy: この地図上におけるこの怪物がプレイヤーがいると思っている位置．
    幻影や透明のクロークなどの効果で実際とは違う場合がある．

   -mtrack: Monster track???. 行動ルーチンに使われているみたいだけど，
    僕にはそれがなんなのかをはっきりさせられなかった．

   -mappearance: ミミック，かの魔法使い用． プレイヤーに見える外見．

   -m_ap_type: mappearanceが示しているもの．次のどれか：
	M_AP_NOTHING    0/* mappearanceは未使用 − 怪物はそれ自身に見える */
	M_AP_FURNITURE  1/* 階段，扉，祭壇，等． */
	M_AP_OBJECT     2/* アイテム */
	M_AP_MONSTER    3/* モンスター */

   -mtame: 懐き具合のレベル．もし0より大きければ手懐けられていて，穏やかで
    あることを意味する．（手懐けられた怪物がプレイヤーに怒っていることは
    意味しない．）

   -mspec_used: 怪物の特殊攻撃のタイムアウト． つまり，怪物はこのカウンター
    が0になるまでドラゴンブレスのような特殊能力を使えない．

   -female: 雌か否か． 1 = はい，0 = いいえ．
   -minvis: 怪物は透明か． 1 = はい，0 = いいえ．
   -cham: 怪物が実際にはカメレオンかどうか． 1 = はい，0 = いいえ．
   -mundetected: 怪物は(ヘビのように)隠れていてプレイヤーに見つかって
    いないか． 1 = はい，0 = いいえ．
   -mcan: 怪物は無力化の杖(もしくは呪文)の影響を受けているか．
   -mspeed: 怪物の速度．2ビットで4状態を表す．
   -mflee: 怪物は現在怯えているか．
   -mfleetim: (7ビット) 怯え状態用タイムアウト．
   -mcansee/mblinded: 怪物は目が見える ／ 盲目用タイムアウト.
   -mcanmove/mfrozen: 怪物は動ける ／ 麻痺用タイムアウト．
   -msleep: 怪物は眠っている．
   -mstun: 怪物は麻痺している．
   -mconf: 怪物は混乱している
   -mpeaceful: 怪物は友好的である．
   -mtrapped: 怪物は罠にかかっている．
   -mleashed: 怪物は紐につながれている．
   -isshk: この怪物は店主である． 
   -isminion: 神の御使いである．
   -isgd: 番兵である．
   -ispriest: 僧侶である．
   -iswiz: イェンダーの魔法使いである．
   -wormno: ワームのとき，ワームが作成されるごとに数値を設定する．
    （階層内において31匹が最大数）
   -mstrategy: 継続的な戦略 （とても特別な怪物に使われる）
    （訳注：mflag3に基づくこのモンスターの行動原理に使用される．
      眠り続けたり，移動したり，移動先位置など）
   -mtrapseen: かかったことのあるトラップの種類別マップ．
   -mlstmv: 1度に2回行動するのを防ぐ（？）
    （訳注：移動したときにそのターンは攻撃行動を起こさないようにする）
   -mgold: この怪物がどれだけ金持ちか．
   -minvent: 'obj'構造体へのポインタ．このアイテム群は怪物が独自に持つ
    'monst'構造体と同じような連鎖リストである．これはそのリストの始点である．
    （アイテムを全く持っていない場合はNULLになる．)
   -mw: この怪物が装備している武器．
   -misc_worn_check: ワーム制御コード用のなんらかの値 (?).
    （訳注：ワーム制御用ではなく，防具や鞍などの装備有無を管理．）
   -weapon_check: 怪物が武器を拾ったときにチェックするフラグ．
   -mnamelth: 怪物に付けられた名前の長さ．
   -mxlth: 拡張部分の構造体のサイズ．怪物ごとに異なる．
    ほとんどがこれを持つ．
   -meating: 怪物の食事のタイムアウト
   -mextra: 拡張部分の構造体へのアクセスポインタ． 例えば，店主は頻繁に
    これを使用する．

   うがぁぁぁ！  このバカデカイ構造体は君を感動させちゃうと確信するね．
   気にすんな． 少なくても初めのうちは全ての項目を相手にする必要はないし．

   手始めにこの質問に答えるべきだろう． 君の怪物に何らかのアイテムや，
   M-FLAGSで反映できないような特殊な能力は必要かい？ もしイエスなら，
   makemon.cファイルを開いて'm_initweap'関数を探してくれ．

   (UNIXユーザーへ：

   関数を探すときは，ちょっとしたツールで驚くほど効率的になるよ：

     'ctags'コマンドでアイテム用のインデックスを作るには
     以下の行を実行する．

		ctags *.c          (srcディレクトリー配下で)

     これで'TAGS'ファイルが生成されるはずだ． この後コマンド'vi -t m_initweap'
     を実行すればすぐにm_initweap関数の実装箇所を得られるだろう．

     また，'grep'コマンドは文字列を検索するのに向いている．例えば，
     カメレオンのコードを探したい？ 次のようにすればいい．

		grep -i chamaleon | more

   ここまで)


   m_initweap関数はモンスターが生成されるときに必要なアイテムを持たせる．
   この巨大なswitch処理 (switch (mtmp->data->mlet) ) によって種類別に
   どんなアイテムを必要とするかを定めてるんだ． これは'mongets'関数と一緒に
   使われる．（付録Aの100近いよく使う関数完全リストを参照）

   最も簡単なのは，作ろうとしている怪物に似た怪物を探してそのコードをコピー
   することだ． この方法なら既知のアイテムを怪物に渡すのは難しくないよ．
   怪物の鎧＆武器をランダムにするためのrn2()関数の使い方に気をつけること．

   本当に興味深い怪物は，独自の鎧，武器，アイテムを持っていたり，独自の種別
   だったり，独自の攻撃をもっているものだ．（そうでなきゃ標準の怪物の
   バリエーション 〜よりタフなイモリとか，弱っちいドラゴンとか〜 でしかない．）
   そのために新しいアイテムを追加する方法は次の章を参考にしてくれ．
   今は新しい攻撃や行動を追加するにはどうすればいいかを見てみよう．


   7.1. 新しい攻撃タイプの追加

   monattk.hファイルを編集しよう．（訳注：SLASH'EMにはattk.hというファイルが
   あるが，0.0.7現在では使用されていない．） AT_TENTが定義されている行(3.1.3時点)
   の後ろに次のような行を追加しよう． 
   (訳注：SLASH'EM 0.0.7ではAT_MULTIPLY 17までが使用されているので18を
    使用すること．)

       #define AT_HELLO    16    /* こんにちわ！と言って君を殺してみる */

   これで新しい攻撃タイプになる． 今度は，新しいダメージを定義しよう．
   AD_FAMNの定義の後ろに次の行を追加しよう．
   (訳注：SLASH'EM 0.0.7ではAD_TCKL 45までが使用されているので46を
    使用すること．)

       #define AD_HELLO	   39    /* 君は挨拶される */


   今度はsrcディレクトリに移動し，mhitu.cファイル（怪物(monster)がユーザー
   (user)を攻撃(hit)）を開く． hitmsg()関数の中にAT_HELLO攻撃タイプに関す
   るコードを追加しよう． たとえば次のコードの直後に：

                case AT_EXPL:
                case AT_BOOM:
#if 0 /*JP*/
                        pline("%s explodes!", Monnam(mtmp));
#else
                        pline("%sは爆発した！", Monnam(mtmp));
#endif
                        break;
                case AT_MULTIPLY:
                        /* No message. */
                break;

   次のようなコードを追加する：

                case AT_HELLO:
#if 0 /*JP*/
                        pline("%s says hello to you!", Monnam(mtmp));
#else
                        pline("%sはこんにちはと言った！", Monnam(mtmp));
#endif
                        break;

   ここで僕達は最もよく使う関数の一つpline()を紹介しよう． これは画面に
   メッセージを一つ表示するんだ． (詳しくは付録Aを見てくれ)

   次にmattacku()関数に注目しよう． AT_HELLO攻撃用のコードをこの中の
   'switch(mattk->aatyp)'に追加することになる． 最も簡単なのは
   'hand to hand'のケースに追加する方法だ．

   今度はhitmu()関数を見てくれ． ここにAD_HELLO用のコードを追加する．
   例えば次のコードの直後に：

            case AD_FAMN:
#if 0 /*JP*/
                pline("%s reaches out, and your body shrivels.",
#else
                pline("%sは腕を伸ばした，あなたの体はしなびた．",
#endif
                        Monnam(mtmp));
                exercise(A_CON, FALSE);
                if (!is_fainted()) morehungry(rn1(40,40));
                /* plus the normal damage */
                break;

   次のようなコードを追加する：

            case AD_HELLO:
                hitmsg(mtmp, mattk);
                make_confused(2,FALSE);
                break;

   （訳注：SLASH'EM 0.0.7の場合はAD_FAMNのあとにいくつかのコードがすでに
   　追加されているのでAD_ENCHの場合のコードの後が望ましい．）
   見てのとおりこの新しい攻撃はアンバーハルクの睨みのように混乱させる．

   これでmhitu.cファイルの編集は終わりだ． 今度はmhitm.c（怪物(monster)が
   怪物(monster)に攻撃(hit)）を同様に処理する． つまり，怪物の場合の
   AT_HELLOによる攻撃は別物にすることができるんだ．


   7.2. 新しい怪物の能力の追加

   この章では，怪物用の行動を追加する方法について説明するよ． 例として，
   怪物が解呪の巻物を読めるようにするコードを追加してみよう．

   muse.cファイルを開いて#define MUSE_WAN_SPEED_MONSTER 7 の行を探して
   新しい能力を追加するんだ．
   （訳注：NetHack 3.3以降では#define MUSE_BULLWHIP 8 および
   　#define MUSE_POT_POLYMORPH 9 が追加されているので，この後に
   　数値を10にして追加すること．）

	#define MUSE_SCR_SCARE_MONSTER 8

   その次に，find_misc関数内の次のコードを探し，

		if(obj->otyp == WAN_POLYMORPH && obj->spe > 0 && !mtmp->cham
				&& monstr[monsndx(mdat)] < 6) {
			m.misc = obj;
			m.has_misc = MUSE_WAN_POLYMORPH;
		}

   次のコードを追加する：
                if(obj->otyp == SCR_REMOVE_CURSE) {
                        m.misc =obj;
                        m.has_misc = MUSE_SCR_REMOVE_CURSE;
                }

   これで怪物は内部的な行動として解呪の巻物を探せるようになる．
   use_misc()関数内部で実際に行動を行うコードを追加しよう．

   次のコードの直後に

	case MUSE_WAN_POLYMORPH:
		mzapmsg(mtmp, otmp, TRUE);
		otmp->spe--;
#if 0
		(void) newcham(mtmp, muse_newcham_mon(), TRUE, vismon);
#else
/*JP
		(void) mon_poly(mtmp, FALSE, "%s changes!");
*/
		(void) mon_poly(mtmp, FALSE, "%sは姿を変えた！");
#endif
		if (oseen) makeknown(WAN_POLYMORPH);
		return 2;

   次のコードを追加しよう．

        case MUSE_SCR_REMOVE_CURSE:
                {
                register struct obj *obj;
                mreadmsg(mtmp,otmp);
#if 0 /*JP*/
                pline("%s feels than someone is helping %s.",Monnam(mtmp),
                                 mtmp->female?"her":"him");
#else
                pline("誰かが%sを助けているような気がした．",Monnam(mtmp));
#endif
                if (!otmp->cursed) {
                   for(obj=mtmp->minvent;obj;obj=obj->nobj)
                      if (otmp->blessed || obj->owornmask ||
                         (obj->otyp == LOADSTONE)) {
                            if (mtmp->mconf) blessorcurse(obj,2);
                            else uncurse(obj);
                      }
                }
                if (oseen && !objects[SCR_REMOVE_CURSE].oc_name_known
                     && !objects[SCR_REMOVE_CURSE].oc_uname)
                     docall(otmp); /* not makeknown() */
                m_useup(mtmp, otmp);
                return 2;
                }


   7.3. 'mextra'構造体の追加

   怪物の行動を本当に興味深いものにするにはmonst構造体への新しい変数の定義
   しなきゃだめだよね． 例として，新しい怪物が神に祈れるようにする追加をし
   たいとしよう．まず考えられるのは，怪物が2ターン連続で祈るのを防ぐために
   タイムアウトを持たせることだ． 従って，僕達は新しい要素をmonst.hの
   'struct monst'に次のように追加しなくちゃならない：

		long praytime;

   だけど，これだと僕達の怪物しか使わない，この4バイトを割り当てた変数を全
   ての怪物が持つことになる．

   その代わりに新しい構造体を定義したほうがいい． 君用の新しいインクルード
   ファイルでやるのが一番だよ．

	struct onlymymonster {
		long praytime;
	};

   そして，monst.c内のこのモンスターの定義のextension length領域に
   'sizeof(struct onlymymonster)'を設定する． 新たな変数を参照するには次の
   ようにする：

		((struct onlymymonster *)&(mon)->mextra[0])->praytime

		     (monはmonst構造体へのポインタ)

   このような酷い記述を短縮するには#defineを使うんだ：

	#define MYMONSTER(mon)   ((struct onlymymonster *)&(mon)->mextra[0])

   そうすれば次のように書けるよ．

	MYMONSTER(mon)->praytime

   mextra部分の使い方の例はeshk.hを参照するといいかな．（店主用のコード）


   7.4. databaseへの項目追加

   databseソースファイル (dat/data.base) はコメント('#'で始まる行)の点在す
   る多数の項目で構成されている．
   （訳注：JNetHackおよびJSLASH'EMではdat/jdata.baseが使用される．）

   それぞれの項目は，独立した行になっている多数のパターンで構成されてる．
   怪物やアイテムがプレイヤーに表示される説明文（大抵は引用）によって
   説明されていて，パターンはそれの識別に使われるんだ．


   7.4.1. パターン一覧

   パターン一覧の最も単純な形式は，同じテキストを表示されたい異なる
   アイテムや怪物の一覧で構成される． 例えば次のとおり：

	incubus
	succubus
		The incubus and succubus are male and female versions of the
		same demon, one who lies with a human for its own purposes,
		usually to the detriment of the mortals who are unwise in
		their dealings with them.

   （訳注：jdata.baseでは次のとおり：
	インキュバス
	サキュバス
	incubus
	succubus
		インキュバスとサキュバスは同じ種類の魔神で，それぞれ男性と女
		性である．それらと関係を持つ愚かな人間は大抵手痛い目に合う．
   　）

   注：この文章に例題を載せるにあたってインデントしてある． 実際のdata.base
   では，パターンは行頭に詰めて記述し，説明文は_１_タブあけて書くこと．

   全てのテキストを列挙するのでは充分ではない場合もたまにある． そのような
   場合のために，'?'と'*'の特殊文字が使用できるよ． '?'は一文字に対応し，
   '*'は0文字以上に対応する． 例えば次のとおり：

	*giant
	giant humanoid
	        Giants have always walked the earth, though they are rare in
		these times.  They range in size from little over nine feet
		to a towering twenty feet or more.  The larger ones use huge
		boulders as weapons, hurling them over large distances.  All
		types of giants share a love for men - roasted, boiled, or
		fried.  Their table manners are legendary.

   （訳注：jdata.baseでは次のとおり：
	*巨人
	*giant
	giant humanoid
		巨人はいつも大地を歩いていたが，最近では彼らは非常に希な存在
		となっている．彼らのサイズと言ったら，9フィートたらずのから
		空にもそびえる20フィート以上のものまでいる．大きなものは巨大
		な岩を武器として使い，遠くからでもそれを投げつける．全ての種
		類の巨人は人間（焼いたり，煮たり，揚げたりしたもの）が大好き
		という点で共通している．彼らのテーブルマナーは伝説的だ．
   　）

   この場合，"*giant"パターンは次の怪物に対応する：
   	giant, stone giant, hill giant, fire giant, frost giant, storm giant.
   （訳注：日本語版では次の怪物に対応する：
   	巨人，岩石巨人，丘の巨人，炎の巨人，吹雪の巨人，雷の巨人）

   特殊文字を含むパターンに無関係なテキストがマッチしちゃう場合，これを取
   り除かなきゃだめだよね． これをやるために，1つ以上の取り消しパターンを
   列記することができるんだ． 取り消しパターンは他のパターンよりもパターン
   一覧の前の方に記述しなくちゃならなくて，もしそれがマッチした場合はその
   項目を無視する． こいつらは'~'を先頭につけて記述するんだ（この文字その
   ものはパターンの一部にはならない）． 例えば次のとおり：

	~slime mold
	*mold
		Mold, multicellular organism of the division Fungi, typified
		by plant bodies composed of a network of cottony filaments.
		The colors of molds are due to spores borne on the filaments.
		Most molds are saprophytes.  Some species (e.g., penicillium)
		are used in making cheese and antibiotics.
			[ The Concise Columbia Encyclopedia ]

   （訳注：jdata.baseでは次のとおり：
	*モールド
	カビ
	~slime mold
	*mold
		モールド，カビ，糸状菌．菌類に属する多細胞有機体，綿のような単
		繊維組織網で構成された植物の体の典型．モールドの特色は単繊維で
		の胞子の発芽に帰する．ほとんどのモールドは死体寄生である．ある
		特定の種は(例えばペニシリン，青カビ)はチーズや抗生物質を作るの
		に使われる．
		[ The Concise Columbia Encyclopedia ]
   　）

   "~slime mold"パターンを列記しなかった場合，プレイヤーがslime moldの情報
   を尋ねたときにこの項目が表示されちゃうだろう（slime moldが"*mold"に対応
   してしまうから）．

   最後に，上のほうで書かなかったコトをいくつか記述しておくよ．

     - パターンは空白やタブ文字では始められない． これは空白で始まるものは
       説明文とみなしてしまうことから起こる問題だ．

     - 対応するものが見つかるまでdata baseにおける記載順で項目をスキャンす
       る（見つかった時点でスキャンは停止する）．これは2つ以上の項目に対応
       するパターンに合致するテキストがあったときに最初の項目が次の項目を
       隠しちゃうこと意味する．

       普通はこれ(を取り消しパターンの代わりに使うの)は避けるべきなんだけ
       ど，使える場合もあるかもしれない．

     - テキストはパターンと比較される前に小文字に変換されるから，全てのパ
       ターンは小文字で書いておかなきゃならない．

     - ユーザが複数形で入力した場合，このゲームはアイテムやモンスターなら
       単数形に変換してから使おうとするんだ．だから，通常はパターン一覧に
       単数形と複数形を両方指定しておく必要はないよ．

   7.4.2. 説明文

   説明文はタブ文字で始まる複数の行で構成される（テキストを出力する時には
   この最初の文字は取り除かれる）．

   次のASCIIマークアップ規約が適用される：

     _xxx_                        xxxを強調表示
     [xxx]                        xxxをボールド表示
     - (語中)                     ハイフン
     - (数字の間)                 半角ダッシュ
     - (空白で囲まれた)           全角ダッシュ
     ...                          省略記号
     ... (行中にそれだけ)         縦の省略記号
     "xxx"                        xxxを会話文として囲む
     number'                      数字をフィート表示

   注： これらはゲーム中においてまったく解釈はされないけれど，一貫とした形
   式でプレイヤーにテキストを表示するのに役立つ．

   行は，右行端未調整（つまり左揃え）であり，67文字より短くしておく必要が
   ある． パラグラフの分割は前節を短い行で示すべきである（字下げは使うべき
   ではない）． パラグラフ間の空行は，引用もしくは他の特殊な目的のために使
   用するべきである（詩における句の間の分離等）．終止符（および短文を終え
   る他の句読点）には2つの空白文字を続けるべきである．


8. 新しいアイテムの追加
----------------------

   8.1 'objects'配列

   6章において，mons[]配列を紹介したよね． 今度は'objects'配列の番だ．
   それはobjclass構造体の集まりで，次の要素によって構成されているんだ：
   （objclass.hより）

   oc_name_idx: アイテムの実際の名前．
   oc_descr_idx: 不明であるときのアイテムの説明（未識別名）．
   oc_uname: ユーザによって付けられた説明 (Callコマンドによって)．
   oc_name_known: 1のとき，実際の名前が常に表示される．
   oc_merge: 1のとき，同じアイテムとまとまる．
   oc_uses_known: 完全な説明が与えられるべきである．
   oc_magic: 魔法のアイテムである．
   oc_charged: このアイテムは充填可能である．
   oc_unique: このアイテムはユニークアイテム（イェンダーの魔除け 等）
   oc_nowish: プレイヤーはこれを願えない．
   oc_big: 大きいアイテム
   oc_dir: 方向指定が必要か？ 次のいずれか：
					   NODIR
					   IMMEDIATE
					   RAY
	 （訳注：武器および道具では攻撃方法を示す． 次のいずれか
	   PIERCE	SLASH	EXPLOSION	WHACK
	   ）
   oc_material: 何で構成されているか？ 次のいずれか：
	   LIQUID	WAX		VEGGY	FLESH	PAPER
	   CLOTH	LEATHER		WOOD	BONE	DRAGON_HIDE
	   IRON		METAL		COPPER	SILVER	GOLD
	   PLATINUM	MITHRIL		PLASTIC	GLASS	GEMSTONE
	   MINERAL

   oc_oprop: このアイテム用のプロパティ． 例：FIRE_RES，ANTIMAGIC，等々

   oc_class: アイテム種別．例：WEAPON_CLASS，FOOD_CLASS，等々
   oc_delay: アイテムを使用するときにかかる時間．
   oc_color: アイテムの色：次のいずれか．
           BLACK	RED		GREEN		BROWN
	   BLUE		MAGENTA		CYAN		GRAY
	   NO_COLOR	ORANGE_COLORED	BRIGHT_GREEN	YELLOW
	   BRIGHT_BLUE	BRIGHT_MAGENTA	BRIGHT_CYAN	WHITE

       ただし次の名前も別名で使用できる (color.hより)：

		#define HI_OBJ          MAGENTA
		#define HI_METAL        CYAN
		#define HI_COPPER       YELLOW
		#define HI_SILVER       GRAY
		#define HI_GOLD         YELLOW
		#define HI_LEATHER      BROWN
		#define HI_CLOTH        BROWN
		#define HI_ORGANIC      BROWN
		#define HI_WOOD         BROWN
		#define HI_PAPER        WHITE
		#define HI_GLASS        BRIGHT_CYAN
		#define HI_MINERAL      GRAY
		#define HI_ZAP          BRIGHT_BLUE

   oc_prob: アイテムの生成確率． 同じアイテム種別でのこの数値の合計が1000に
     なる必要がある．
   oc_weight: 重さ．
   oc_cost: 店における基準価値． 実際の価格は魅力とアロハシャツに依存する．
   oc_wsdam:
   oc_wldam: 小型/大型の怪物に与えうる最大ダメージ．
   oc_oc1:
   oc_oc2: アイテムに何がしかの±値を設定するフラグ． 種類によって異なる
     振る舞いをする． 武器ではoc1は攻撃ボーナスでoc2は未使用． 防具では
     oc1は強化レベルでoc2は〜(錆など)，魔法書ではoc2は呪文レベルを指す．
   oc_nutrition: 栄養価．

   （訳注：以下はSLASH'EM 0.0.7に存在するが上記で説明されていない項目）
   #define oc_bimanual oc_big: 武器の場合，アイテムとして使える武器である．
   #define oc_bulky    oc_big: 防具の場合，行動の妨げになる．
   oc_tough: 硬い宝石/指輪である．
   oc_subtyp: 副種類
   #define oc_skill    oc_subtyp: 武器，魔法書，道具，宝石の場合，スキル．
   #define oc_armcat   oc_subtyp: 防具の場合，防具の種類を表す．次のいずれか
   		ARM_SHIELD	ARM_HELM	ARM_GLOVES	ARM_BOOTS
   		ARM_CLOAK	ARM_SHIRT	ARM_SUIT
   #define oc_range    oc_wsdam: 射撃武器の場合，強さと独立した射程距離．
   #define oc_rof      oc_wldam: 射撃武器の場合，連射回数．
   #define oc_hitbon   oc_oc1: 武器の場合，攻撃ボーナス．
   #define w_ammotyp   oc_oc2: 射撃武器の場合，弾の種類．次のいずれか．
   		WP_GENERIC	WP_BULLET	WP_SHELL	WP_ROCKET
   		WP_GRENADE
   #define a_ac        oc_oc1: 防具の場合，AC． do.cのARM_BONUSマクロで使用．
   #define a_can       oc_oc2: 防具の場合，魔法無力値． mhitu.cで使用．
   #define oc_level    oc_oc2: 魔法書の場合，呪文レベル

   利便のために，アイテム種別を追加するいくつかの"#define"が
   定義されている． 例：

#define WEAPON(name,app,kn,mg,bi,prob,wt,cost,sdam,ldam,hitbon,metal,color) \
        OBJECT( \
                OBJ(name,app), BITS(kn,mg,1,0,0,1,0,0,bi,0,metal), 0, \
                WEAPON_CLASS, prob, 0, \
                wt, cost, sdam, ldam, hitbon, 0, wt, color )

   WEAPONマクロによって新しい武器を追加を行うことで，全ての武器において
   いくつかの初期値を共通的に設定できるんだ．

   WEAPON，FOOD，ARMOR，RINGなど，ほぼ全ての場合のマクロがあるから
   君の場合にぴったり合うものを使うように，次のことを覚えておいて欲しい：

      - 同じアイテム種別ごとにまとめて設定すること．
      - アイテム種別ごとの生成確率をチェックすること．
      - 最も容易かつ通常は既存のアイテムをコピーして修正する．

   ここでは次のような例題を扱おう：

      ARMOR("Merlin's helm", "sharp-pointed cap", 0, 1, 0, POLYMORPH_CONTROL,
         0, 1, 10, 50,10, 0, CLOTH, BRIGHT_BLUE)

      ARMOR("sport t-shirt", NULL, 1, 0, 0, 0, 0, 0, 5, 3,10, 0, CLOTH, BLUE)

      TOOL("self-compatible personal computer",NULL,1, 0, 0, 0, 0,80,  200,
         PLASTIC, GR AY)

      FOOD("hamburger",            0, 1,  8, 0, VEGGY, 300, BROWN)


   全てobjects[]配列に設定する． 今度は，アイテム種別ごとに依存する仕上げに
   触れよう． だが最初に，いくつかの汎用事項を書いておく：

   a) アイテム種別の最初や最後にアイテムを追加しない． 次のような形の
   コードが*たっぷり*あるからだ．

		if ( (object > FIRST_OF_CLASS_X )
		   && (object < LAST_OF_CLASS_X ) )  
		   {   
			/* Assume object is of class x */
		   }
		   else 
		        /* Print some strange fatal error */

   b) 簡単なアイテムで始めること． もっといいのは，追加したアイテムの効果を
   設定しないこと． → 警告/エラーメッセージがどこを修正すべきかを教えてくれる．
    後で君が思うがままに完全にするとして，始めはシンプルに．

   c) 全種別に使用できるいくつかの一般関数があるんだ．
   例：アイテムを食べたときの特殊効果，無力化したとき，浸したとき，等．
   それらを追記するためのヒントをここにあげておくよ．

   - zap.c の cancel_item()関数に，無力化したときの挙動が定義されている．
   - potion.c の dodip() に，アイテムを浸したときの特殊効果がある．
   - eat.c の eatspecial()．
   - do.c の dropy()に，アイテムを落としたとき（クリスナイフなど）．

   （訳注：和訳について
   　JNetHackやJSLASH'EMではアイテムの和訳にjtrnobj.datファイルに定義された
   　英語名:日本語名の変換テーブルを用いて行っている． 日本語名はこちらに
   　定義しよう． なお，英語名と日本語名の両方の末尾に':'を記述する必要が
   　ある． 日本語名の末尾のほうは忘れやすいので注意しよう．上記の例だと
   　次の行を追加すればいい。
		]Merlin's helm:		マーリンの兜:
		]sport t-shirt:		スポーツＴシャツ:
		(self-compatible personal computer:	自作パソコン:
		%hamburger:		ハンバーガー:
   　また，あまり長いアイテム名をつけるとアイテム一覧などではみ出るので
   　注意しよう． 
   　最も現時点でかなりはみ出すアイテムもある．ユーザの名づけ以外での最長は
   　「透明な呪われていない油の塗られた燃えないとても焦げたプラチナイェン
   　ダー印エクスプレスカードと呼ばれるクレジットカード(予備の武器;装備し
   　ていない)」かな？ 鋭利武器じゃないので「毒の塗られた」は付かない．）


   8.1. 道具の追加

   新しく追加した道具には使用(apply)時の効果を持つはずだよね． それは
   apply.cファイルの doapply()関数によって定義されている．
   アイテムのタイプに依存する巨大なswitch文 (switch(obj->otyp)) があるんだ．
   そこでは種々のアイテムがその大文字化した名前で参照されてることに注意．
   それは onames.h ファイルの中にmakedefsコマンド（覚えてる？）で生成され
   ているんだよ．

   道具を使ったときどうするかをcase文の中に定義してある． 簡単なコードなら
   直接そこに書いてあるし，そうでないなら'use_<道具名>'関数を定義してある．
   これらの関数はとても有益な機能を提供しているので，それを勉強するのは
   とてもいい練習になるよ．


   8.2. 杖の追加

   杖は2つの理由から特別なコードを持たなければならない． 床に刻むときと〜
   もちろん振ったときのだ．

   engrave.cファイルにあるdoengrave()関数に注目しよう． そこに特定のcase文
   と君の望むメッセージやコードを追加しなくちゃいけない． 方向指定のある杖
   とない杖には違いがあることに注意すること．

   zap.cで杖の方向指定の有無で異なる関数を編集する必要がある：

      方向指定なし        --------- >  zapnodir() 関数

      方向指定あり        --------- >  bhitm() 関数 (怪物にあたったとき)
                              |---- >  bhito() 関数 (アイテムにあたったとき)
                              |---- >  zapyourself() 関数 (まぬけにも君に)


   一般的に杖の追加は他のアイテムより難しい． 手始めは他のものにしたほうが
   いいだろう．


   8.3. 薬の追加

   この場合はファイル potion.c の次の関数を見る：

   peffects():  薬を飲んだときに何が起こるかを記述する．

   potionhit(): 怪物に薬をぶつけたときに何が起こるかを記述する．

   potionbreathe(): 薬の霧の効果．

   他にも浸した場合の特殊効果を追加するために dodip()関数を修正したくなる
   かもしれない．


   8.4. 防具/武器の追加

   特殊な機能を欲しいと思わない限り，何もしなくてもよい．

   コードを追加するといいと思われる場所は，weapon.c の dmgval()関数だ．
   そこでは，特定の怪物を特定の武器で攻撃したときの特殊ダメージボーナスを
   追加できる．


   8.5. 指輪の追加

   この場合の関数は次を見ればいい：

   - do.c の dosinkring()． 流し台に指輪を落としたときの効果を記述する．

   - do_wear.c の Ring_on()．指輪をはめたとき何が起こるかを記述する．

   - do_wear.c の Ring_off_or_gone()． さっきと反対のとき．

   - eat.c の eatring()． 変身したプレイヤーが指輪食べたとき．


   8.6. 魔除けの追加

   指輪と全く同じ．do_wear.c の Amulet_on()とAmulet_off 関数を編集すること．


   8.7. 魔法書の追加

   最初に，spell.cの次の2つの関数を修正する：

   study_book(): 呪文の学習について．
   spelleffects(): 呪文の詠唱について．

   多くの呪文の振る舞いは杖と似ているので，杖の場合と同様に zap.c の
   関数bhitm()，bhito() および zapyourself()を修正する必要があるかも．


   8.8. 食料の追加

   ちょうど以下の2つの関数が対象だ． 両方ともeat.cにある．

   fprefx(): 最初の一口のときに呼ばれる．
   fpostfx(): 食べ終わったときに呼ばれる．

   少なくともデフォルトの振る舞いのcase行を追加しなくちゃいけない．


9. 新しい種類の部屋の作成
---------------------------

   新しい種類の部屋を作成する方法を説明するために，次の例を使うつもりだ：
   診療所，これは看護婦でいっぱいの部屋になる．

   全ての最初に，includeディレクトリに移動してmkroom.hファイルを開こう． 
   次の行の後ろに
		#define TEMPLE 10
   次の行を追加する．
		#define CLINIC 11
   （訳注：NetHack 3.4では部屋がANTHOLE 13にまで，SLASH'EM 0.0.7では
   　FUNGUSFARM 20にまで増えているので適宜位置や数値を調整すること．）

   その時，SHOPBASE とそれ以降をずらしてやる必要があるのがわかると思う．
   変更分が反映されるように定義すること． そうするとMAXRTYPEは22になる．
   （訳注：MAXRTYPEはNetHack 3.4では25になる．SLASH'EM 0.0.7では店は
   　SHOPBASEとの差分で定義してあるのでSHOPBASEを修正すればよい．）

   今度はrm.hを開いて次の行の後ろに
		Bitfield(is_cavernous_lev,1);

   次の行を追加する．
		Bitfield(has_clinic,1);

   こうすることで診療所のある階層にいるときに，特別なメッセージ（例えば
   救急車のような音）を追加することができるようになるんだ．

   includeファイルでの作業はこれで全部だ． srcディレクトリに行ってmkroom.cを
   開いて，mkroom()関数を見つけて次の行の後ろに
		case BARRACKS:  mkzoo(BARRACKS); break;

   次の行を追加しよう．
		case CLINIC:     mkzoo(CLINIC); break;

   （訳注：NetHack 3.4では次の行の後ろに，
		case ANTHOLE:	mkzoo(ANTHOLE); break;

   　SLASH'EM 0.0.7では次の行の後ろになる．
		case FUNGUSFARM: mkzoo(FUNGUSFARM); break;
   　）

   ここに記したのは店ではない部屋の追加方法だ． 今回修正した場所
   の手前で(roomtype >= SHOPBASE)であるときはmkshop()を呼び出して
   いるからわかると思う． 'mkclinic()'関数を完璧に定義してもいいが，
   それはmkzoo()のコードを使用するほうが実に簡単になる．この関数は
   部屋を作って(fill_zoo関数で)特定の怪物でそこをいっぱいにする．

   その後に，mkshop()関数を修正しなければならない． 何故か？ ウィザードモード
   にて環境変数SHOPTYPEを使用して部屋の種類を指定することができるからだ．
   例えば，SHOPTYPE='G'としてNetHackを起動したとき，最初の階層に雑貨屋が
   生成されるし，'Z'ならば動物園，等々… 必ずしも必要ではないけど，
   新しく作る部屋のために新しいSHOPTYPEを追加しておくのはいい考えなのは
   明らかだよね． テストが素早くできるんだもの．

   それで，次の行の後ろに
			if(*ep == 't' || *ep == 'T' || *ep == '\\'){
                                mkzoo(COURT);
                                return;
                        }

   続けて次のように入力しよう．

	#ifdef CLINIC
                        if(*ep == 'c' || *ep == 'C'){
                                mkzoo(CLINIC);
                                return;
                        }
	#endif 

   今度はfill_zoo()のところに移動して．次の行の後ろに

	        case ZOO:
	            goldlim = 500 * level_difficulty();
		    break;

   次の行を追加する．
	#ifdef CLINIC
		case CLINIC:
		    break;
	#endif

   今度は部屋の中に生成する怪物を選択しよう． 次の行の後ろに

  	#ifdef ARMY
                    	(type == BARRACKS) ? squadmon() :
	#endif

   次の行を追加する．
	#ifdef CLINIC
			(type == CLINIC) ? &mons[PM_NURSE]:
	#endif

   これで，部屋の種類がCLINICならば生成される怪物が看護婦になった． ここで
   いくつか記しておこう． もっと複雑な関数〜例えばcourtmon()関数とか〜を
   追加すれば複数種類の怪物を配置できる． 部屋の中央に別の怪物を選択
   したい場合は蜂の巣の女王蜂を例にするといい．

   部屋にアイテムを追加したい場合， 次の数行を見てみよう．

                    case BARRACKS:
                        if(!rn2(20))    /* the payroll and some loot */
                            (void) mksobj_at((rn2(3)) ? LARGE_BOX : CHEST,
                                             sx, sy, TRUE);
                        break;

   これは1/20の確率で大きな箱を生成するんだ． 僕達は次のように書ける．

	#ifdef CLINIC
		    case CLINIC:
			if(!rn2(10))
			    (void) mksobj_at(ICE_BOX,sx,sy,TRUE);
			break;
	#endif

   こうすればランダムにアイスボックスを生成できる． これは何もコンテナ
   である必要はなく，どのようなアイテムでもかまわない．

   最後に階層に診療所があることを示すフラグを追加する．

	#ifdef CLINIC
              case CLINIC:
                  level.flags.has_clinic = 1;
                  break;
	#endif

   これで再コンパイルしてSHOPTYPE変数を使って新しい部屋を試すことができる
   けど，このままでは通常の迷宮には生成されない． これを解決するにはmklev.cを
   修正すればいい．

   まず，the clear_level_structures()関数に次の行を追加することから始めよう：
		level.flags.has_clinic = 0;

   これでフラグがリセットされる．

   後は次のコードを見てほしい：

        if(depth(&u.uz) > 1 &&
           depth(&u.uz) < depth(&medusa_level) &&
           rn2(depth(&u.uz)) < 3) mkroom(SHOPBASE);
        else if(depth(&u.uz) > 4 && !rn2(6)) mkroom(COURT);
        else if(depth(&u.uz) > 6 && !rn2(7)) mkroom(ZOO);
        else if(depth(&u.uz) > 8 && !rn2(5)) mkroom(TEMPLE);
        else if(depth(&u.uz) > 9 && !rn2(5) &&
           !(mons[PM_KILLER_BEE].geno & (G_GENOD | G_EXTINCT))) mkroom(BEEHIVE);
        else if(depth(&u.uz) > 11 && !rn2(6)) mkroom(MORGUE);
        else

   見てのとおり，ここが部屋が生成されるときの定義がある場所である． 例えば，
   動物園は6階より深い場合に1/7の確率で，等々… つまり次のように行を追加すれば

	#ifdef CLINIC
        if (depth(&u.uz) > 10 && !rn2(4)) mkroom(CLINIC)
	#endif

   迷宮の10階より深いところに診療所が時々生成されるようになる．


   次に，sounds.cファイルを開いてほしい． dosounds()を探して次の行の後ろに

	#ifdef ARMY
	    if (level.flags.has_barracks && !rn2(200)) {
		static const char *barracks_msg[4] = {
			"hear blades being honed.",
			"hear loud snoring.",
			"hear dice being thrown.",
			"hear General MacArthur!",
		};
		You(barracks_msg[rn2(3)+hallu]);
		return;
	    }
	#endif /* ARMY */

   次のを追加する．
	#ifdef CLINIC
	    if (level.flags.has_hospital && !rn2(200)) {
		static const char *hospital_msg[4] = {
			"hear something about streptococus.",
			"smell chloroform nearby.",
			"hear someone cursing viruses.",
			"seem to hear Doctor Frankenstein.",
		};
		You(hospital_msg[rn2(3)+hallu]);
		return;
	    }
	#endif /* CLINIC */

   これで診療所のある階層でおかしなメッセージをランダムに表示される．

   後は，hack.cを開いてcheck_special_room()を見て，プレイヤーが診療所に
   入ったときの挨拶を追加しよう．

	        case CLINIC:
#if 0 /*JP*/
                    You("enter a modern hospital.");
#else
                    You("モダンな病院に入った．");
#endif
                    break;

   それから次の後に
	#ifdef ARMY
                            case BARRACKS:
                                level.flags.has_barracks = 0;
                                break;
	#endif

   次を追加する．
	#ifdef CLINIC
                            case CLINIC:
                                level.flags.has_clinic = 0;
                                break;
	#endif

   そして最後にsp_lev.cを開いてfill_room()関数内の次の後に
	#ifdef ARMY
		    case BARRACKS:
			level.flags.has_barracks = TRUE;
			break;
	#endif
   次を追加する．
	#ifdef CLINIC
		    case CLINIC:
			level.flags.has_clinic = TRUE;
			break;
	#endif

   コードを再コンパイルしよう． おめでとう． 新しい部屋を追加が追加されたよ．


10. 新しい種類の店の作成
----------------------------

   この章では，僕達は例として『ペット店』を追加してみよう．
   （訳注：SLASH'EM 0.0.7にはすでにペット専門店が追加されている．）

   新しい店の追加は新しい部屋の追加と同様だ． mkroom.hファイルから始める
   必要がある． 次の後に
	
		#define BOOKSHOP 20

   次の行を追加する．
		#define PETSHOP 21

   そしてUNIQUESHOP，CANDLESHOPおよびMAXRTYPEの数値を増やす． (もちろん，もし
   すでに9章において部屋を追加しているなら，それに応じた正しい数値にすること．)
   （訳注：NetHack 3.3以降ではBOOKSHOPは23に，SLASH'EM 0.0.7では(SHOPBASE+11)に
   　なっている． いずれにせよ，UNIQUESHOPの値より前の値で定義するように修正する
   　必要がある．）

   今度は店のコードのほとんどが記述されれているshknam.cファイルを開こう．
   最初に注目するのはいくつかの'static const char *shk何か[]'配列だ．
   これらは個々の種類の店の店主の名前である． そこで，shkgeneral[]の定義の
   後にペット店用の名前の配列を追加しよう．

   static const char *shkpetshop[] = {
	   "Valoo","Tisney","Jakuna",
	   ""
	   };

   配列の最後は文字列""で終わることに注目． 本当は3つ以上の名前を設定する
   べきだけど，例題には充分だからね．

   後ろに'const struct shclass shtypes[]'配列が定義されている． それが
   店の種類を設定するところで，個々の要素は次のようになっている：

   - 店の名称 (例:"雑貨屋")．
   
   - 文字で認識される店の種類．(例: SCROLL_CLASS) ウィザードモードにおける
    SHOPTYPE環境変数で使用する文字として扱われる．

   - % 店の生成確率．全種類の合計が100になるようにすること． つまり，新しい
    店を追加したら他の店(一つまたは複数)の確率を下げなければならない．

   - アイテムの置き方：
		D_SCATTER = 普通の置き方
		D_SHOP    = 店のような置き方
		D_TEMPLE  = 寺院のような置き方
	（訳注：現在の店の定義ではD_SHOPしか設定していない．
	　そもそもこの設定を参照するコードも存在しない．）

   - ここで売られるアイテムを個々の生成確率を前に置いて記述する． 例:
	 {{85, RING_CLASS}, {10, GEM_CLASS}, {5, AMULET_CLASS}, {0, 0}}

      意味: 指輪 (85%ストック)，宝石(10%)，魔除け(5%)． 最後にNULLのペアを
      置くこと．
      なお，具体的なアイテムを(種類の代わりに)定義したい場合はマイナス記号
      を次のように指定する．
	 {{90, WAND_CLASS}, {5, -LEATHER_GLOVES}, {5, -ELVEN_CLOAK}, {0, 0}}

      この配列が5要素の長さで（mkroom.hで）定義されていることに注意すること．
      つまり，店は5種類/アイテム以上をストックすることができない．（もちろん，
      君はいつでもその数を増やす選択はできるけど．）

   - 店主名の配列 〜shk何かの配列〜

   そして，今回の場合は次のように設定しよう：

/*JP
   {"pet shop", VENOM_CLASS, 5, D_SHOP,
*/
   {"ペット店", VENOM_CLASS, 5, D_SHOP,
	{{70, -FIGURINE},{20,-TRIPE_RATION},{10,-LEASH}}, shkpetshop}

   意味：人形を70%，乾し肉を10%，紐を10%生成する．
   また，この店はSHOPTYPE="."としたときか，店が生成されるごとに5%の確率で
   生成される． 雑貨屋の確率を44から39に変更する．

   これで全てだ． 簡単だろう？

   コードを再コンパイルして設定を確認しよう：

   export SHOPTYPE=.   （またはset SHOPTYPE=. OSやunixシェルに依存する．）
   nethack -u wizard -D


11. 最後に
-----------

   ほかにもたくさんこのゲームに追加できるけど，これで終わりにしよう．
   ここからは君自身の手でやって欲しい． これが君に有益であることを望むよ．
   最後にいくつかアドバイスを：

      1. コードにたくさんのコメントを入れてくれ． 経験上，一週間から二週間で
        自分が何故そうしたのかを忘れてしまう．

      2. rec.games.roguelike.nethackニュースグループで新しいアイデアの
        情報交換をしてくれ． 彼らは君のアイデアを洗練するしたり新しいアイデア
        を考えるのを手伝ってくれるだろう．

      3. 君の修正を開発チームに送ってくれ． (メールアドレスは
        nethack-bugs@linc.cis.upenn.edu).  君は永遠の生を得られるかも．

      4. nethackをたくさんプレイしてくれ．


   Good luck and happy hacking!!



		---------------------------
		付録A  リファレンス関数一覧
		---------------------------

   君の利便性のためのいくつかの興味深い関数：

怪物の名前出力関数
------------------------
		これらは全てmonst構造体へのポインタをパラメタに持って文字列を
		返却する．

char *mon_nam(struct monst *)
                the rust monster       it     the invisible orc              Fido
                錆の怪物               何者か 姿の見えないオーク             Fido
char *l_monnam(struct monst *)
		rust monster           it     invisible orc                  dog called fido
                錆の怪物               何者か 姿の見えないオーク             Fidoという名の犬
char *Monnam(struct monst *)
		The rust monster       It     The invisible orc              Fido
                錆の怪物               何者か 姿の見えないオーク             Fido
char *Adjmonnam(struct monst *, const char *)
		The poor rust monster  It     The poor invisible orc         The poor Fido
                かわいそうな錆の怪物   何者か かわいそうな姿の見えないオーク かわいそうなFido
char *Amonnam(struct monst *)
		A rust monster         It     An invisible orc               Fido
                錆の怪物               何者か 姿の見えないオーク             Fido
char *a_monnam(struct monst *)
		a rust monster         it     an invisible orc               Fido
                錆の怪物               何者か 姿の見えないオーク             Fido


アイテムの名前出力関数
-----------------------

char *xname(struct obj *)
		"poisoned arrow"
		"毒の塗られた矢"
char *doname(struct obj *)
		"poisoned +0 arrow"
		"毒の塗られた+0 矢"
char *an(struct obj *)
		"a poisoned arrow"
		"毒の塗られた矢"
char *An(struct obj *)
		"A poisoned arrow"
		"毒の塗られた矢"
char *The(struct obj *)
		"The poisoned arrow"
		"毒の塗られた矢"
char *the(struct obj *)
		"the poisoned arrow"
		"毒の塗られた矢"
char *makeplural(char *) 
		複数形の文字列を取得する． 実に巧妙に，
		例えば"homunculus"は複数にすると"humunculi"になる．
		（訳注：日本語版ではばっさり省略して文字列のコピーを返す．）
char *makesingular(char *) 
		上記と反対のことをする．
		（訳注：日本語版ではUSE_MAKESINGULARを有効化しない限り
		　ばっさり省略して文字列のコピーを返す．）


表示関数
-----------------
		(詳しくはdoc/window.docファイルを参照してください)

pline(char *, ...)
		標準のprintf()関数と同じ引数で，メッセージ領域に結果を
		表示する． これはコード全域にわたって非常に多く使われている．
You(char *, ...)
		「あなたは〜」というメッセージを表示する短縮形．
		pline("You sit") と You("sit") は同じ出力になる．
		（訳注：日本語版では"あなたは"を前につける．）
Your(char *, ...)
		「あなたの〜」というメッセージを表示する短縮形．
		pline("Your hands glow") と Your("hands glow") は同じ出力になる．
		（訳注：日本語版では"あなたの"を前につける．）
verbalize(char *, ...)
		これもまたprintf()と同じように振舞うが，文字列は「」で囲われて
		表示される． 他の怪物が起こした音や声に使用される．
impossible(char *, ...)
		"impossible:"を前につけてエラーメッセージとして表示する．
		（訳注：現在は"impossible:"は付けられない．
		　文字列を表示と同時にpaniclogとしてファイルにも出力し，
		　"プログラムに障害発生 - #quitしたほうがよさそうだ．"と
		　表示する．）


いくつかのアイテム関連の関数
--------------------------------

struct obj *readobjnam(char *)
		文字列からアイテムを生成する． 主に願いルーチンから使用
		される．
	（訳注：この関数はNetHack 3.4以降は次のように変更された．
	　struct obj *readobjnam(char *,struct obj *,boolean)
		指定された文字列に該当するアイテムが存在しない場合，
		第2引数objを返却する． NULLを指定すればNULLが返る．
		第3引数booleanはwizkit（外部に設定するwizardモード
		起動時の初期所持品リスト）が設定されているときにFALSEにされ，
		メッセージ表示を行わない．）
int weight(obj)
		アイテムの重量を返却する． (コンテナに使える)
void docall(struct obj *)
		プレイヤーに対してアイテムに何と名前をつけるか尋ねる．
makeknown(obj->otyp)
		これは本当の関数ではなく，マクロである．
		指定した種類のアイテムを識別する．
void curse(struct obj *)
		アイテムを呪う．
void uncurse(struct obj *)
		アイテムを解呪する．
void bless(struct obj *)
		アイテムを祝福する．
void unbless(struct obj *)
		アイテムの解祝する．
void move_object(struct obj *,int,int)
		アイテムをx, yの位置に移動する．
void remove_object(struct obj *)
		アイテムを削除する．
void place_object(struct obj *,int,int)
		アイテムをx, yの位置に置く．
int bhito(struct obj *, struct obj *)
		アイテムを第2引数に設定された杖の効果に晒す．
void cancel_item(struct obj *)
		アイテムを無力化光線に晒す．


Several monster related functions
---------------------------------
struct monst *newmonst(struct permonst *)
		新しい'monst'構造体をメモリに確保する． 怪物のチェインリスト
		には追加しない． 局所的なプロセスは次のとおり：
			mtmp = newmonst(ptr->pxlth);
			*mtmp = zeromonst; /* 構造体内の全項目をクリア */
			mtmp->nmon = fmon;
			fmon = mtmp;
		直接使うべきではない． makemon()を使うほうがよい．
struct monst *makemon(struct permonst, int, int)
		他の2つの引数(x,y)によって指定された位置に新しい怪物を
		作成する． 成功すれば新しい作成された怪物が返却され，そうで
		なければNULLを返却する． 最初の引数がnullである場合，
		ランダムな怪物を生成する．
		位置(x,y)に0を指定することで場所の指定をランダムにできる．
	（訳注：この関数にはNetHack 3.2以降で第4引数が追加された．
	　このパラメタでモンスターを生成するときのフラグを複数指定できる
	　ようになった．フラグは次のとおり：
		NO_MM_FLAGS	0x000 フラグなし
		NO_MINVENT	0x001 アイテムを持たせずに生成する．
		MM_NOWAIT	0x002 STRAT_WAITMASKを設定せずに生成する．
		MM_EDOG		0x004 ペット用のedog構造体を追加して生成する．
		MM_EMIN		0x008 御使い用のemin構造体を追加して生成する．
		MM_ANGRY	0x010 怒らせた状態で生成する．
		MM_NONAME	0x020 （幽霊の）名前を付けずに生成する．
		MM_NOCOUNTBIRTH	0x040 生成カウンタを増やさない(復活用)．
		MM_IGNOREWATER	0x080 堀/水溜りを避けて生成する．
		MM_ADJACENTOK	0x100 隣接座標の使用を許可する．
	　）
void relmon(struct monst *mon)
		怪物を画面と怪物リストから解放する．
boolean mnearto(struct monst *,xchar, xchar, boolean)
		可能ならば指定位置(付近)に怪物を配置する． boolean引数
		は他の怪物を強制的に移動するかどうか． 次の値を返却する：
		1 - x, yにmtmpを配置するために怪物をx, yから移動させた場合
		0 - ほとんどの場合
struct permonst *grow_up(struct monst *, struct monst *)
		怪物をより大きいバージョンに成長させる． 後半のmonst構造体
		パラメタが指定された場合，それを犠牲者とする（訳注：その怪物を
		倒した結果レベルアップしたとする）． そうでない場合はレベル
		アップの薬とみなす．
void mongone(struct monst *)
		怪物を消滅させる． 構造体を解放する．
void setmangry(struct monst *)
		怪物を怒らせる． すでに怒っている場合は何もしない．
boolean angry_guards(register boolean)
		この関数は街の番兵たちをを怒らせるのに使う． パラメタが
		trueならばメッセージを表示する． 番兵が街に存在する場合は
		TRUEを返却する．
void pacify_guards()
		名が体を表す．（訳注：番兵をなだめる）
void wakeup(struct monst *)
		怪物を起こす（かつ怒らせる）．
		Wake up -and angry- a monster.
void wake_nearby()
		近くの怪物を起こす．
void mon_to_stone(struct monst *)
		怪物を同種の石像に変える．
boolean monnear(struct monst *, x, y)
		指定したマスは指定した怪物が移動したり攻撃したりできるマスか？
int minwater(struct monst *)
		怪物と水との親和性をチェックする．
		0ならば生き残り，1ならば溺れる．
		（訳注：怪物がいる場所の水溜り/堀をチェックする）
		（訳注：NetHack 3.4以降ではminliquidに改名され，溶岩溜りに
		　関してもチェックされるようになった．）
int rndmonnum()
		ランダムに選択した怪物種別番号．

音関連の関数
----------------

void dosounds()
		現階層に依存する音（店，玉座など）を作る．
void growl(struct monst *)
		怪物は幸せそうな音を発する．
void yelp(struct monst *)
		怪物は幸せでなさそうな音を発する．
void whimper(struct monst *)
		怪物は死に掛けてるような音を発する．
		Monster is about to die.
void beg(struct monst *)
		怪物は食べ物をねだるような音を発する．
int domonnoise(struct monst *)
		怪物が何らかの音を発する．
int dotalk()
		#chatコマンド

怪物⇔アイテム 関数
----------------------------

int mongets(struct monst *, int)
		アイテムを生成して怪物に渡す． intがonames.h（makedefsで生成）
		で定義されたアイテムの識別子になる． 例：BLUE_DRAGON_SCALE_MAIL
void m_useup(struct monst *, struct obj *)
		アイテムは怪物に消費される． obj構造体は解放される．
void mpickobj(struct monst *, struct obj *)
		アイテムは怪物に拾われる．
void mpickgems(struct monst *)
		怪物は足元の宝石を拾う．
void mpickgold(struct monst *)
		怪物は足元の金貨を拾う．
void mpickstuff(struct monst *)
		怪物は足元の物を拾う． 何を拾うかはこの怪物の種類のM-FLAGS
		に依存する．
void meatobj(struct monst *)
		怪物はその場にある全てを食べる． ゼラチンキューブ用に使う．
void meatgold(struct monst *)
		高価な食事 :-)
boolean can_carry(struct monst *, struct obj *)
		そのアイテムをその怪物が運べるならばTRUEを返す．
struct obj *make_corpse(struct monst *)
		怪物の死体や「特別な」死体を生成する．死体を残さない怪物なら
		何も生成しない．
		（訳注：「特別な」死体とは，ユニコーンの角やドラゴンの鱗，
		　ゾンビの腐った死体などのこと）

店関連の関数
----------------------

struct monst *shop_keeper(char rmno)
		指定した部屋番号に対応する店主を返却する． 使い方の例：
			struct monst *shkp;
			shkp=shop_keeper(*in_rooms(u.ux,u.uy,SHOPBASE));
int inhishop(struct monst *)
		店主が彼の店の中にいる場合はtrueを返却する．
void mkshobj_at(const struct shclass *,int,int)
		店内の指定のマスに適切な種類のアイテムを生成する．
int shkinit(const struct shclass *,struct mkroom *sroom)
		指定された部屋に店主を生成する．
boolean saleable(int,struct obj *)
		指定された店で取り扱える種類のアイテムの場合はTRUEを返却する．
		（訳注：NetHack 3.2以降では店の指定はintではなく
		　struct monst *で店主を指定するように変更された．）

その他興味深い関数
---------------------------

int rn2(int x)
		0以上x未満の乱数を返却する．
		( 0 <= rn2(x) < x )
int rnl(int x)
		0以上x未満の乱数を返却するが， rn2()とは異なってプレイヤー
		の幸運値が結果に反映される． 幸運であるほど0に近い値になり
		やすく，不幸であるほどx-1に近い値になりやすい．
char *getrumor(int)
		「噂」の文字列を返却する． int=1のときは常に正しい噂で，
		-1は誤ったものを意味し，0はランダムである．
		（訳注：NetHack 3.2以降では第2引数char *に噂格納用のバッファ
		　を指定することになった． NetHack 3.3.1以降は第3引数boolean
		　にクッキー専用占いを除外するかを指定するようになった．）
void exercise(int, boolean)
		能力値（A_INT,A_CHA,A_WIS,A_STR,A_DEX）を鍛える．
		trueならば増やしてFALSEならば減らす．
find_misc() 
use_misc()
		双方の関数はmuse.c内で怪物ができることやそれを使うために，
		アイテムや行動を探すのに使われる．
void mkroom(int)
		指定した種類の部屋を生成して配置する．
boolean has_dnstairs(struct mkroom *)
		部屋に下り階段があるときtrueを返却する．
boolean has_upstairs(struct mkroom *)
		部屋に昇り階段があるときtrueを返却する．
schar depth(d_level)
		地表からの階層の深さを返却する．
		（種々の迷宮の階層は同じ深さを持ちうる．）
		（訳注：分岐の迷宮は分岐点の階数とそこからの分岐内での階数を
		　持つので，それの合計を返却する．）
doengrave()
		ユーザが床に刻む
int bhitm(struct monst *, struct obj *)
		怪物を第2引数で指定された杖や呪文の効果に晒す．
int zapyourself(struct obj *)
		名が体を表す． プレイヤーが自らを杖や呪文で撃つ．
void zapnodir(struct obj *)
		方向指定のない杖を振る．
int breaks(struct obj *, boolean)
		アイテムを壊す． booleanフラグでアイテムがfobjチェインに
		あるかどうかを指定する．
	（訳注：NetHack3.2の時点でこの関数はなくなった．
	　代わりに以下の2つの関数が導入された．
		int hero_breaks(struct obj *, int, int, boolean)
			プレイヤーが原因でアイテムを破壊する． int,intは
			アイテムの位置を指定する． booleanは投擲や落下の
			場合はtrueで蹴りや魔法の場合はfalse． 実際に
			アイテムが破壊されたら1を，されなかったら0を返却．
		int breaks(struct obj *, int, int)
			プレイヤーの行動以外の原因でアイテムを破壊する．
			int,intはアイテムの位置を指定する． 実際にアイテム
			が破壊されたら1を，されなかったら0を返却．）
int peffects(struct obj *)
		薬を飲んだときの効果用関数．
void potionhit(struct monst *, struct obj *)
		Potion hits monster.
		薬を怪物にぶつける
void potionbreathe(struct obj *)
		（薬の）霧の効果．
void dosinkring(struct obj *)
		流しに指輪を落とす．
void eatring(struct obj *)
		指輪を食べたプレイヤーの変化．
	（訳注：この関数はNetHack 3.2の時点で
		void eataccessory(struct obj *)
	　に変更され，魔除けも対象に入った．）
void Ring_on(struct obj *)
		指輪をはめたときの効果．
void Ring_off_or_gone(struct obj *,boolean)
		指輪を外したときの効果． 失くした（盗まれた）場合は
		booleanフラグを有効にする．
	（訳注：なお，この関数はglobal関数ではなく，外から使うときは
	　Ring_off(struct obj *)またはRing_gone(struct obj *)を使う．）
void Amulet_on()
void Amulet_off()
		対象が魔除けである以外は同じような処理を行う．
void fprefx(struct obj *)
		食物を口に入れたときの処理．
void fpostfx(struct obj *)
		食物を飲み込み終わったときの処理．
int study_book(struct obj *)
		魔法書を覚える．
int spelleffects(struct obj *, boolean)
		呪文を詠唱する． booleanフラグを有効にするとプレイヤー自身を
		対象にする． （訳注：booleanフラグは発動方向が必要な魔法に
		おいて確認せずに自分自身に向けて使う．僧侶の蘇生の魔法
		や死人使いのアンデッドを使役する魔法，溺れたときの瞬間移動
		の魔法が発動するときに使われる．）

