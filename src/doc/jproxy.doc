原文 proxy.doc
訳 So-Miya (so-miya@users.sourceforge.jp)

最初に

このファイルはプロキシーウィンドウインターフェースについて記述したものであ
る． まだ完成にはほど遠い．

内容：
	I.    このコンポーネントの概要
	II.   標準手続きの追加
	III.  標準コールバックの追加
	IV.   拡張の追加

I.   このコンポーネントの概要

このプロキシーウィンドウインターフェースは多くのコンポーネントで構成されて
いる． これは実行可能なゲームとリンクされるウィンドウインターフェースとし
て動作するとともに，ゲームとの通信を処理するために外部ウィンドウポートとリ
ンクできるライブラリとして使われることを意図しているためである． これらの
モジュールは以下のタイプに分割されている：

A.  両方のプロセスで使用される共通モジュール (proxycom)
B.  プロキシーウィンドウインターフェース (winproxy)
C.  実行可能なゲーム内で使用されるユーティリティモジュール (proxyutl)
D.  外部プロセスからのみ使用されるクライアントモジュール (proxyclnt)

メインである実行可能なゲームはwinproxy，proxyutl，およびproxycomのモジュー
ルから構成され，外部インターフェースはproxyclntとproxycomのモジュールから
成るnhproxyライブラリで構成される．

外部ポートとしてウィンドウインターフェースを構築する場合，proxyutlモジュー
ルは単にwinproxyモジュールの特殊ケースとして扱われる． しかしながら，ウィ
ンドウインターフェースが外部ポートまたは内部ウィンドウインターフェースとし
て構築されるように設計されるならば，コードは内部ウィンドウインターフェース
内でproxyutlモジュールを使用することで普通は簡単にできる．

プロキシーウィンドウインターフェースは次のように使用される多くのincludeファ
イルを持つ：

A.  共通includeファイル：

nhxdr.h
proxycom.h

B.  プロキシーウィンドウインターフェースのincludeファイル：

winproxy.h

C.  外部プロセスincludeファイル：

proxyclnt.h
proxycb.h

II.  標準手続きの追加

まず，新しい手続きの名称を選ぶこと． この文書上では，選ばれた名称の小文字
版を参照する場合は${name}と記述し，大文字版を参照する場合は${NAME}と記述
することにする．

次のようにソースを修正すること：

A.  win/proxy/ext_protocol.html

 o 新しい手続きIDを一覧に未使用のID番号を使って追加する．
 o 手続きとそのパラメータおよび結果の説明を行う新しいセクションを追加する．
 o 必要なら，プロトコルバージョンやNhExtを何とかする．
 o パラメータおよび結果の説明形式はwin/proxy/Makefile.*にて記述されたtest
   手続きを有効とするために，SunのXDR言語の文法に従う必要がある．説明形式
   は<pre>〜</pre>で囲わなければならない． このときのこのhtmlタグは内部の
   記述とは独立した行である必要がある．
 o rpcgenが実行できるならば，rpcgen-nhext_xdr.cを構築し，記述をチェックす
   るためのmakefileを使うことができる．
   （訳注：rpcgenはSunが出しているRPCインタフェースを生成するプリコンパイ
   　ラ． インターフェース定義を元にClient-ServerのC言語用スタブを生成する．）

B.  include/prxyclnt.h

 o window_ext_procs構造体の最後に適切なパラメータと適切な結果を持つ
   関数ポインターを保持する新しいフィールドを追加する． フィールド名は
   winext_${name}とするべきである．

C.  include/proxycom.h

 o 上で指定したIDを使って一覧に新しい手続きIDを追加する：
	#define EXT_FID_${NAME}		0x##
 o nhext_rpc()用のパラメータと結果が複雑すぎる場合，proxy_${name}_req，
   proxy_${name}_resといった構造体を定義し，それを使ったXDR関数を定義する．
   （追加部分は#ifdef NHXDR_H 〜 #endifで囲っておこう．）
 o NhExtプロトコルのバージョンを上げた場合，それに対応する値に更新すること．

D.  win/proxy/compxdr.c

winproxy.hでXDR関数を宣言した場合，このファイルでそれを定義する必要がある．
多くのXDR関数は複合型フィールドごとに単純に標準XDR関数を呼んで返却値を
ビット単位でANDして返す構成になっている． XDR functions should not return
early if an error occurs so the use of logical AND operators is
generally to be avoided. （訳注：よくわからなかった．「エラーが発生した場
合は，AND論理操作の演算は一般的に無効になるので，すぐにXDR関数は失敗で終了
する．」？）

E.  win/proxy/winproxy.c

上記で宣言したproxy_${name}関数を定義する． この関数は関連手続きを実行した
いときゲームによって呼ばれる． 次のように記述する必要がある：

 o パラメータに必要な何らかの準備を行うこと（通常はしない）．
 o ウィンドウインターフェースから返却される値を格納するバッファを初期化す
   ること． XDR規約ではNULLポインタはXDRがメモリ確保するべきことを表し，
   NULLポインタ以外は確保済みのメモリを使用することを表す．
 o RPCパケットをウィンドウインターフェースに送信し，返信を受信するために
   nhext_rpc()を呼ぶこと．
 o 結果を返却すること．（もしあれば）

F.  win/proxy/proxysvc.c

このモジュールはウィンドウインターフェースの手続きのサポートを実装する．
次のように記述する必要がある：

 o 受信要求を処理するstatic関数の定義は次のとおり：
	static void FDECL(proxy_svc_${name}, \
				(unsigned short, NhExtXdr *, NhExtXdr *));
 o 処理関数を次のとおりに定義すること：
   - nhext_rpc_params()を呼び出し，XDRハンドルと記述どおりのパラメータ書式
     に則った手続きのパラメータの要求を通して受信パラメータをデコードする
     こと．
   - ゲームの要求するいかなるアクションにも応答すること．
   - ゲームへの返却の準備をするためにnhext_rpc_params()を呼び出し，XDRハン
     ドラと記述どおりのパラメータ書式に則った手続きのパラメータの返信を通
     してnhext_rpc_params()のアクションの結果をエンコードすること． 注：こ
     の手続きが結果を返却しない場合はゲームに対して常に空の結果を返却する
     ことになる．
 o services配列に次のような項目を追加する：
	EXT_FID_${NAME},		proxy_svc_${name},
 o これが非同期手続きである（すなわち，結果を返さなかったり，呼び出し先の
   実行が完了するのを待つ必要がない）場合，async_procedures[]配列に手続き
   用の項目を追加すること． すでに同じ範囲（1〜32，33〜64，〜）のIDを持つ
   非同期手続きがある場合，その範囲を含むマスクに新しい手続きと一致する
   ビットを追加すればよい． これがその範囲における最初の非同期手続きの場合
   は次のような新しいマスクを追加する：
	1 << EXT_FID_$(NAME) - EXT_FID_$(BASE_NAME),
   $(BASE_NAME)はその範囲における最初の手続きの名称とする（非同期かどうか
   にかかわらず）．

G.  外部ウィンドウインターフェース

外部ウィンドウインターフェース毎のwindow_ext_procs構造体に新しく定義した
winext_${name}フィールドを追加すること． これは，適切な結果を返却しない
フック関数（新たな手続きをサポートしないウィンドウインターフェース用），
またはext_protocol.htmlにて新規に記述された新しい手続きとして動作する関数
のどちらであってもそうするべきである．

H.  ゲームのソース

ゲームのソースの適切な位置でproxy_${name}を呼ぶコードを追加すること．

III.  標準コールバックの追加

まず，新しいコールバックの名称を決定すること． この文書上では，選ばれた名
称の小文字版を参照する場合は${name}を使い，大文字版を参照する場合は${NAME}
を使うことにする．

次のようにソースを修正すること：

A.  win/proxy/ext_protocol.html

 o 新しいコールバックIDを一覧に未使用のID番号を使って追加する．
 o コールバックとそのパラメータおよび結果の説明を行う新しいセクションを追加する．
 o 必要なら，プロトコルバージョンやNhExtを何とかする．
 o パラメータおよび結果の説明形式はwin/proxy/Makefile.*にて記述されたtest
   手続きを有効とするために，SunのXDR言語の文法に従う必要がある．説明形式
   は<pre>〜</pre>で囲わなければならない． このときのこのhtmlタグは内部の
   記述とは独立した行である必要がある．
 o rpcgenが実行できるならば，rpcgen-nhext_xdr.cを構築し，記述をチェックす
   るためのmakefileを使うことができる．

B.  include/proxycb.h

 o 適切なパラメータと適切な結果を持つ関数としてproxy_cb_${name}を宣言する．

C.  include/proxycom.h

 o 上で指定したIDを使って一覧に新しいコールバックIDを追加する：
	#define EXT_CID_${NAME}		0x##
 o nhext_rpc()用のパラメータと結果が複雑すぎる場合，proxy_${name}_req，
   proxy_${name}_resといった構造体を定義し，それを使ったXDR関数を定義する．
   （追加部分は#ifdef NHXDR_H 〜 #endifで囲っておこう．）
 o NhExtプロトコルのバージョンを上げた場合，それに対応する値に更新すること．

D.  win/proxy/compxdr.c

proxycb.hでXDR関数を宣言した場合，このファイルでそれを定義する必要がある．
多くのXDR関数は複合型フィールドごとに単純に標準XDR関数を呼んで返却値を
ビット単位でANDして返す構成になっている． XDR functions should not return
early if an error occurs so the use of logical AND operators is
generally to be avoided. （訳注：よくわからなかった．「エラーが発生した場
合は，AND論理操作の演算は一般的に無効になるので，すぐにXDR関数は失敗で終了
する．」？）

E.  win/proxy/proxycb.c

上で宣言したproxy_cb_${name}関数を定義すること． この関数はウィンドウイン
ターフェースがプラットフォーム関連からコールバックされたい場合にそれらから
呼ばれることになる． 次のように記述する必要がある：

 o 必要に応じてパラメータのなんらかの準備を行う（通常は不要）．
 o ゲームから返却される値を格納するバッファを初期化する． XDR規約ではNULL
   ポインタはXDRがメモリ確保するべきことを表し，NULLポインタ以外は確保済み
   のメモリを使用することを表す．
 o RPCパケットをゲームに送信し，返信を受信するためにnhext_rpc()を呼ぶこと．
 o 結果を返却すること．（もしあれば）

F.  win/proxy/callback.c

このモジュールは実行可能なゲームのコールバックのサポートを実装する．次のよ
うに記述する必要がある：

 o 受信要求を処理するstatic関数の定義は次のとおり：
	static void FDECL(callback_${name}, \
				(unsigned short, NhExtXdr *, NhExtXdr *));
 o 処理関数を次のとおりに定義すること：
   - nhext_rpc_params()を呼び出し，XDRハンドルと記述どおりのパラメータ書式
     に則ったコールバックのパラメータの要求を通して受信パラメータをデコー
     ドすること．
   - ウィンドウインターフェースの要求するいかなるアクションにも応答するこ
     と．
   - ウィンドウポートへの返却の準備をするためにnhext_rpc_params()を呼び出し，
     XDRハンドラと記述どおりのパラメータ書式に則ったコールバックのパラメー
     タの返信を通してnhext_rpc_params()のアクションの結果をエンコードする
     こと． 注：このコールバックが結果を返却しない場合はウィンドウポートに
     対して常に空の結果を返却することになる．
 o proxy_callbacks配列に次のような項目を追加する：
	EXT_CID_${NAME},		callback_${name},

G.  win/proxy/winproxy.c

これが非同期コールバックである（すなわち，結果を返さなかったり，呼び出し先
のコールバックが完了するのを待つ必要がない）場合，async_callbacks[]配列に
コールバック用の項目を追加すること． すでに同じ範囲（1〜32，33〜64，〜）の
IDを持つ非同期コールバックがある場合，その範囲を含むマスクに新しいコール
バックと一致するビットを追加すればよい． これがその範囲における最初の非同
期コールバックの場合は次のような新しいマスクを追加する：
	1 << EXT_CID_$(NAME) - EXT_CID_$(BASE_NAME),
$(BASE_NAME)はその範囲における最初のコールバックの名称とする（非同期かどう
かにかかわらず）．

H.  外部ウィンドウインターフェース

新しいコールバックを呼ぶ必要のある外部ウィンドウインターフェースのために
proxy_cb_${name}を呼ぶコードを追加すること．

IV.  拡張の追加

拡張は，ゲームサーバーによって提供され，クライアントから要求されるNhExt標
準において詳述されていないコールバックを許可するのに使用する． 拡張は名前，
バージョン番号，コールバックセットを持つ． ある方法または別の方法によって，
名前とバージョン番号がクライアントとサーバーにとって様々な要求と返信パケッ
トの詳細と供に個々のコールバックの意味を決定するのに十分であることとしてお
く（拡張システムはこれらの詳細を要求する方法をまったく定義しない）．

まず，新しい拡張の名称を決定すること． この文書上では，選ばれた名称を参照
する場合に${name}を使うことにする．

ソースを次のように修正する：

A.  サーバー

拡張をとり扱うために，適切なモジュールにコードを追加する（もしくは新しいモ
ジュールを作成する）． このコードには初期化ルーチンとハンドラを含ませる必
要がある． 初期化ルーチンはプロキシーインターフェースの初期設定中に
proxy_init()によって呼ばれる． それはパラメータ〜拡張用ベースID（拡張の追
加や削除で変更される可能性がある）〜をひとつ持つ． ハンドラはコールバック
を扱うために呼ばれる． それはコールバックのIDと，要求および返信パケットの
ポインターを渡される． 次に，引数int valueと返却value+1を持つコールバック
をひとつだけ持った些細な拡張の例を示す：

	static unsigned short xyzzy_base_id;

	void
	xyzzy_init(base_id)
	unsigned short base_id;
	{
	    xyzzy_base_id = base_id;
	}

	void
	xyzzy_handler(id, request, reply)
	unsigned short id;
	NhExtXdr *request, *reply;
	{
	    int i;
	    switch (id - xyzzy_base_id)
	    {
		case 0:
		    nhext_rpc_params(request, 1, EXT_INT_P(i));
		    i++;
		    nhext_rpc_params(reply, 1, EXT_INT(i));
		    break;
		default:
		    impossible("xyzzy_handler: Bad ID %u (base %u)",
		      id, xyzzy_base_id);
		    nhext_rpc_params(reply, 0);
	    }
	}

B.  win/proxy/winproxy.c

 o 初期化およびハンドラの関数をproxy_extents[]の定義よりも上で，次のように
   宣言すること：
	extern void FDECL(${name}_init, (unsigned short));
	extern void FDECL(${name}_handler,
		(unsigned short, NhExtXdr *, NhExtXdr *));
 o proxy_extents[]に次のような項目を追加すること：
	{ "${name}", "1.0", ${name}_init, 2, ${name}_handler },
    - 1.0の部分をバージョン番号で置き換えること． 複数の拡張のバージョンを
      サポートする必要がある場合，初期化関数を分割して作らなければならない
      が，望むならばいくつかのハンドラ関数は共有にすることもできる． イン
      ターフェースは好きなものを最初に並べる．
    - 2をこの拡張が含むコールバックの数で置き換えること．
